# 师资培训课件 （1）

## 一、 HTML + CSS   

> 难度： ⭐ 到 ⭐⭐

### 1. 十三届省赛水果拼盘 
  
- 考点： `flex`  
```css
#pond {
  display: flex;
  flex-direction: column;
  flex-wrap: wrap;
}
```

### 2. 十三届省赛展开你的扇子

- 考点: `transform: rotate、nth-child`

```css
#box:hover div:nth-child(6) {
  transform: rotate(-10deg);
}

#box:hover div:nth-child(5) {
  transform: rotate(-20deg);
}

#box:hover div:nth-child(4) {
  transform: rotate(-30deg);
}

#box:hover div:nth-child(3) {
  transform: rotate(-40deg);
}

#box:hover div:nth-child(2) {
  transform: rotate(-50deg);
}

#box:hover div:nth-child(1) {
  transform: rotate(-60deg);
}
#box:hover div:nth-child(7) {
  transform: rotate(10deg);
}
#box:hover div:nth-child(8) {
  transform: rotate(20deg);
}
#box:hover div:nth-child(9) {
  transform: rotate(30deg);
}
#box:hover div:nth-child(10) {
  transform: rotate(40deg);
}
#box:hover div:nth-child(11) {
  transform: rotate(50deg);
}
#box:hover div:nth-child(12) {
  transform: rotate(60deg);
}
```

### 3. 十三届国赛新鲜的蔬菜	

- 考点: `flex`
  
```css
#box1 {
  display: flex;
  justify-content: center;
  align-items: center;
}

#box2 {
  display: flex;
  justify-content: space-between;
}

#box2 .item:nth-child(2) {
  align-self: flex-end;
}

#box3 {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
}

#box3 .item:nth-child(2) {
  align-self: center;
}

#box3 .item:nth-child(3) {
  align-self: flex-end;
}

```

### 4. 十四届省赛 [电影院排座位](https://www.lanqiao.cn/problems/5133/learning/)

- 考察: `flex/gird` 、 `nth-child`、`nth-of-type`
- 解题思路：关键点 8 个⼀排、 第 2 、6 外边距 30px
- 答案：

```css
/* gird 布局答案 */
.seat-area {
  margin-top: 50px; /* 设置顶部外边距为50像素 */
  display: grid; /* 将该元素设置为⽹格布局 */
  grid-template-columns: repeat(8, auto); /* 设置8列⾃动宽度的⽹格布局 */
  gap: 10px; /* 设置⽹格之间的间隙为10像素 */
}
/* 以下样式规则定义了每8个座位中第2个和第6个座位的右侧外边距  */
.seat:nth-of-type(8n + 2) {
  margin-right: 20px; /* 设置第2个和第6个座位的右侧外边距为20像素 */
}

.seat:nth-of-type(8n + 6) {
  margin-right: 20px; /* 设置第2个和第6个座位的右侧外边距为20像素 */
}
```

```css
/* flex 布局答案 */
/* seat-area 座位区域 */
.seat-area {
  display: flex;
  flex-wrap: wrap;
  margin-top: 40px; /* 顶部外边距为 40 像素 */
}
/* seat-area 座位 */
.seat {
  margin-left: 10px; /* 左外边距为 10 像素 */
  margin-top: 10px; /* 顶部外边距为 10 像素 */
}

.seat:nth-child(8n + 1) {
  margin-left: 0; /* 每⾏的第⼀个座位的左外边距为 0 */
}

.seat:nth-child(8n + 2) {
  margin-right: 20px; /* 每⾏的第⼆个座位的右外边距为 20 像素 */
}

.seat:nth-child(8n + 7) {
  margin-left: 30px; /* 每⾏的第七个座位的左外边距为 30 像素 */
}
```

- 知识点解析：

- grid 布局：

- `grid-template-columns` ：⽤于定义⽹格列的⼤⼩和数量。
- `grid-gap`：⽤于定义⽹格单元格之间的间距。

- `nth-of-type` 是⼀个 CSS 伪类选择器，⽤于选取⼀组相同类型的元素中的第 n 个元素。
   具体⽽⾔，`:nth-of-type(n)` 匹配其⽗元素下第 ``n` 个同类型的元素。该选择器接受⼀个参数，可以是
   ⼀个具体的数字、关键字 `odd` 或 `even` ，或者公式 `an + b` 。
   以下是⼀些示例：

- `:nth-of-type(2)` 选择其⽗元素下的第⼆个同类型元素。
- `:nth-of-type(odd)` 选择其⽗元素下的所有奇数同类型元素。
- `:nth-of-type(even)` 选择其⽗元素下的所有偶数同类型元素。
- `:nth-of-type(3n + 1)` 选择其⽗元素下每隔 3 个同类型元素中的第⼀个。
  该伪类选择器可以⽤于选择列表、⽹格和其他具有相同类型元素的结构。

- `nth-child` 是⼀个 CSS 伪类选择器，⽤于选择指定元素的⼦元素，它的语法如下：
   `:nth-child(an+b)`
   其中， `a` 和 `b` 是两个可选参数， `n` 表示⼀个整数（0, 1, 2, ...），表示元素在其⽗元素中的位置。 `an+b` 则表示⼀系列满⾜这个公式的元素，其中 a 和 b 为数字，表示这些元素的位置。例如， `2n+1` 表示所有奇数位置的元素。
   下⾯是⼀些常⽤的 `nth-child` 选择器：

- `:nth-child(n)` ：匹配⽗元素的所有⼦元素。
- `:nth-child(even)` ：匹配⽗元素的偶数⼦元素。
- `:nth-child(odd)` ：匹配⽗元素的奇数⼦元素。
- `:nth-child(3)` ：匹配⽗元素的第三个⼦元素。
- `:nth-child(3n)` ：匹配⽗元素的第 3、6、9、12... 个⼦元素。
- `:nth-child(3n+1)` ：匹配⽗元素的第 1、4、7、10... 个⼦元素。
- `:nth-child(-n+4)` ：匹配⽗元素的前 4 个⼦元素。

### 5. 十五届国赛植物灌溉 

- 考点：`grid-area`

```css
.treatment {
  grid-area: 1 / 2 / 4 / 6;
}
.treatment {
  grid-row: 1 / 4;
  grid-column: 2 / 6;
}
```
- 知识点解析：
   
   如果指定了 4 个 `<grid-line>` 值，`grid-row-start` 则会被设为第一个值，`grid-column-start` 为第二个值，`grid-row-end` 为第三个值，`grid-column-end` 为第四个值。

### 高频考点知识点讲解：

`flex` 布局：

- `display: flex;` 将元素设置为弹性容器。
- `flex-direction: row;`：指定主轴方向为水平。
- `justify-content: center;`：在主轴上居中对齐弹性项目。
- `align-items: center;`：在交叉轴上居中对齐弹性项目。
- `flex-wrap: wrap;`：允许弹性项目换行显示。

`grid` 布局：

- `display: grid;`：将元素设置为网格容器。
- `grid-template-columns: repeat(3, 1fr);`：创建具有三列的网格布局。
- `grid-template-rows: 100px 200px;`：创建具有两行的网格布局，行高分别为 100 像素和 200 像素。
- `grid-gap: 10px;`：设置网格单元格之间的间距为 10 像素。
- `grid-column: 1 / span 2;`：指定一个网格项目跨越两列。

`css` 常用新特性:


在 CSS 的 `transform` 属性下，有多个常用的变换函数可以实现元素的旋转、缩放等效果。以下是一些示例：

1. `rotate()`：旋转元素指定角度，按顺时针方向旋转为正值，逆时针方向旋转为负值。
```css
.element {
  transform: rotate(45deg);
}
```

2. `scale()`：按指定比例缩放元素，可以分别指定水平和垂直方向的缩放比例。
```css
.element {
  transform: scale(1.5); /* 等比例放大1.5倍 */
}
```

3. `translate()`：按指定的偏移量移动元素，可以分别指定水平和垂直方向的偏移量。
```css
.element {
  transform: translate(50px, 20px); /* 水平偏移50像素，垂直偏移20像素 */
}
```
- 第一个 值 x 轴偏移量，正数是向右，负数是向左
- 第一个 值 y 轴偏移量，正数是向下，负数是向上

1. `skew()`：按指定角度倾斜元素，可以分别指定水平和垂直方向的倾斜角度。

```css
.element {
  transform: skew(45deg, -20deg); /* 水平方向倾斜45度，垂直方向倾斜-20度 */
}
```
- x 轴倾斜 负数向右，正数向左，y 轴倾斜，正数 正对我们的方向，往左倾斜，负数是往右。y 轴倾斜不是特别常用。

5. `border-radius` 是一个 CSS 属性，用于设置元素的边框圆角效果。通过指定圆角的半径，可以使元素的边框或背景具有圆角的外观。以下是一些示例：

```css
.element {
  border-radius: 10px; /* 四个角都具有 10px 的圆角 */
  border-radius: 50% ; /* 50% 的圆角半径将元素变为圆形 */
}
```

### 总结： HTML+CSS 占分比重  5 - 20 分。高频考点：`flex 布局`,`grid 布局`,`css3 新特性`，其他可能出现的考点 `居中`、`css 基础` 比如颜色、字体大小。

### 备赛建议：HTML + CSS 题目较为简单，题目数量 1 - 2，耗时较短，分数一定要全部拿到。每道题建议用时 5-10分钟。检查看页面效果。


## 二、函数封装题   

> 难度： ⭐⭐ 到 ⭐⭐⭐⭐⭐

### 1. 十三届省赛谁最长

```js
/**
 * 封装函数，传入任意数量的数组，返回长度最大的数组集合（长度相同且为最大的数组存入集合，如果所有数组长度相同，则返回空数组），并将它们分别按升序排序
 */
const getMaxArrays = (...arrays) => {
  if (!arrays || arrays.length <= 0) {
    return [];
  }
  let maxArray = [arrays[0]];
  let j;
  for (let i = 1; i < arrays.length; i++) {
    if (!Array.isArray(arrays[i])) {
      return [];
    }
    // 传入数组与返回数组最后一个比较
    j = maxArray.length - 1;
    // 如果传入数组不是当前最大，则继续下一轮比较
    if (arrays[i].length < maxArray[j].length) {
      continue;
    } else {
      // 如果是当前最大，则清空返回数组，并存入
      if (arrays[i].length > maxArray[j].length) {
        maxArray = [];
        maxArray.push(arrays[i]);
      }
      // 如果与当前最大长度相同，则存入
      else {
        maxArray.push(arrays[i]);
      }
    }
  }

  if (maxArray.length == arrays.length) {
    maxArray = [];
  }
  return maxArray; // 正序输出
};
module.exports = getMaxArrays; //请勿删除
```
### 2.十三届省赛寻找小狼人

```js
Array.prototype.myarray = function (cb) {
  // TODO 带补充代码
  var filteredArray = [];
  for (var i = 0; i < this.length; i++) {
    if (cb(this[i])) {
      filteredArray.push(this[i]);
    }
  }
  return filteredArray;
};
```

###  3. 十三届国赛分一分

```js
/**
 * @param {Object} oldArr
 * @param {Object} num
 * */
const splitArray = (oldArr, num) => {
  // 处理待分割数据为空数组或非数组的情况
  if (!oldArr || oldArr.length == 0) {
    return [];
  }
  // 处理待分割数据为正常数组的情况
  let sortedArr = oldArr.sort((a, b) => a - b);
  // 把一个数组分割成每 num 个 1 组
  let arr = [];
  let len = sortedArr.length;
  for (let i = 0; i < len; i += num) {
    arr.push(sortedArr.slice(i, i + num));
  }
  return arr;
};
module.exports = splitArray; // 检测需要，请勿删除
```

### 4.十三届国赛猜硬币

```js
/**
 * @param {*} input_values input 框中输入的值
 * @param {*} res 输入的值组成的一个新的数组
 * @returns
 */
// 将输入的值中的 `1-9` 数字组成的一个新的数组

function findNum(input_values) {
  let input_values_arr = input_values.split("");
  let res = [];
  // 取出只是数字的部分
  for (let index = 0; index < input_values_arr.length; index++) {
    let input_value = input_values_arr[index];
    if (!isNaN(input_value) && input_value != 0) {
      res.push(Number(input_value));
    }
  }
  res = Array.from(new Set(res));
  return res;
}

//随机生成硬币位置  随机三个 1-9中 三个不重复的随机数 并放入数组中并返回这个数组
let randomCoin = () => {
  let randomNumArr = [];
  while (randomNumArr.length < 3) {
    let num = Math.floor(Math.random() * 9) + 1;
    if (randomNumArr.indexOf(num) == -1) {
      randomNumArr.push(num);
    }
  }
  return randomNumArr;
};

// 请勿删除和修改下面代码
try {
  module.exports = { randomCoin, findNum };
} catch (e) {}


```

###  5.十三届国赛用什么来做计算
```js

// 结果显示框
let result = document.querySelector("#result");
// 计算式子显示框
let formula = document.querySelector("#formula");
// 所有按钮
buttons = document.querySelectorAll(".calc-button");
// 初始化式子为空
let formulaValue = "";
// 初始化结果值为空
let resultValue = "";
// 计算符号
let mark = "";
// 计数，用于判断等号按钮是否被点击
let count = 0;
// 监听按钮的点击事件
for (item of buttons) {
  item.addEventListener("click", (e) => {
    // 获取按钮中的文本
    buttonText = e.target.innerText;
    // 判断是否为乘号
    if (buttonText == "x") {
      buttonText = "*";
      mark = "x";
      if (count == 0) {
        formulaValue += mark;
        formula.value = formulaValue;
        resultValue += buttonText;
      } else {
        formulaValue = resultValue;
        formulaValue += mark;
        formula.value = formulaValue;
        resultValue += buttonText;
      }
    }
    // 判断是否为清空按钮
    else if (buttonText == "AC") {
      resultValue = "";
      formulaValue = "";
      formula.value = formulaValue;
      result.value = resultValue;
    }
    // 判断是否为除号
    else if (buttonText == "÷") {
      buttonText = "/";
      mark = "÷";
      if (count == 0) {
        formulaValue += mark;
        formula.value = formulaValue;
        resultValue += buttonText;
      } else {
        formulaValue = resultValue;
        formulaValue += mark;
        formula.value = formulaValue;
        resultValue += buttonText;
      }
    } else if (buttonText == "(") {
      buttonText = "(";
      mark = "(";
      formulaValue += mark;
      formula.value = formulaValue;
      resultValue += buttonText;
    } else if (buttonText == ")") {
      buttonText = ")";
      mark = ")";
      formulaValue += mark;
      formula.value = formulaValue;
      resultValue += buttonText;
    }
    // 判断是否为等号
    else if (buttonText == "=") {
      let value = eval(resultValue);
      resultValue = value;
      result.value = value;
      count++;
    }
    // 判断是否为开方号
    else if (buttonText == "√") {
      resultValue = Math.sqrt(formula.value, 2);
      result.value = resultValue;
      formulaValue = resultValue;
    }
    // 判断是否为加号
    else if (buttonText == "+") {
      buttonText = "+";
      mark = "+";
      if (count == 0) {
        formulaValue += mark;
        formula.value = formulaValue;
        resultValue += buttonText;
      } else {
        formulaValue = resultValue;
        formulaValue += mark;
        formula.value = formulaValue;
        resultValue += buttonText;
      }
    }
    // 判断是否为减号
    else if (buttonText == "-") {
      buttonText = "-";
      mark = "-";
      if (count == 0) {
        formulaValue += mark;
        formula.value = formulaValue;
        resultValue += buttonText;
      } else {
        formulaValue = resultValue;
        formulaValue += mark;
        formula.value = formulaValue;
        resultValue += buttonText;
      }
    } else {
      formulaValue += buttonText;
      formula.value = formulaValue;
      resultValue += buttonText;
    }
  });
}

```

###  6.十三届国赛JSON 生成器

```js
// 随机生成布尔值
function bool() {
  return !!Math.floor(2 * Math.random());
}
// 随机取 n 到 m 之间的整数
function integer(n, m) {
  return Math.floor(Math.random() * (m - n + 1)) + n;
}

// 生成对象的逻辑
let genobj = (data) => {
  let obj = {};
  for (let key in data) {
    let fn; 
    //1. 如果值是字符串并且包含双大括号 则获取双大括号中间的值
    if (typeof data[key] == "string" && data[key].includes("{{") && data[key].includes("}}")) {
      fn = data[key].slice(2, -2);
      if (fn && fn.includes("(") && fn.includes(")")) {
        try {
          // 把大括号中间的字符串作为函数执行  
          let fnkey = new Function("return " + fn)();
          obj[key] = fnkey;
        } catch (err) {
          // 如果不是可执行函数则需要返回原值 
          obj[key] = data[key];
        }
      } else {
        obj[key] = data[key];
      }
    } else {
      //2. 其他情况返回原值
      obj[key] = data[key];
    }
  }
  return obj;
};

let generateData = (data) => {
  let result;
  // 判断是数组还是对象 
  if (Array.isArray(data)) {
    // 判断数组第一项是否是 repeat 
    if (Array.isArray(data) && typeof (data[0]) == "string") {
      // 设置数组和数组长度长度
      let arr = [], arrlength = 0;
      // 获取 repeat 的中的数字
      let num = data[0].slice(9, -3);
      if (num.length == 1) {
        // 获取到的 num 是字符传，需要转化成数字 
        arrlength = +num;
      } else {
        // 随机数组长度
        let numarr = num.split(',')
        arrlength = integer(Number(numarr[0]), Number(numarr[1]));
      }
      // 循环数组，生成数据数组中的每一项数据
      for (let i = 0; i < arrlength; i++) {
        let item = genobj(data[1])
        arr.push(item);
      }
      result = arr;

    } else {
      // 如果没有 repeat 则里面数组第一项是对象
      result = [genobj(data[0])];
    }
  } else {
    result = genobj(data);
  }
  return result;
};



try {
  module.exports = { generateData };
} catch (e) {
}

```
### 7. 十三届国赛商城管理系统	
```js
/**
 * @param {*} menuList 传入的数据
 * @return {*} menus 转化后的树形结构数据，auths 转化后的权限列表数组
 */
const getMenuListAndAuth = (menuList) => {
  let menus = [];
  let sourceMap = {};
  let auths = [];
  menuList.forEach((m) => {
    m.children = []; // 增加孩子列表
    sourceMap[m.id] = m;
    auths.push(m.auth);
    if (m.parentId === -1) {
      menus.push(m); // 根节点
    } else {
      sourceMap[m.parentId] && sourceMap[m.parentId].children.push(m);
    }
  });
  return { menus, auths }; // 获取菜单数据和权限数据，请勿修改此行代码
};
```

### 8. 十四届省赛 ISBN 码校验与生成	

```js
// 将用户输入的带分隔符的isbn字符串转换只有纯数字和大写X字母的字符串
function getNumbers(str) {
  return str.replace(/[^0-9xX]/g, "").toUpperCase();
}

// 验证当前ISBN10字符串是否有效
/*
  有效的ISBN10字符串的前九位可以是任意数字，最后一位校验位的值取决于前九位数字。

  校验位计算方法：用1-9这9个数依次乘以前面的9位数，然后求它们的和除以11的余数。如果余数为10，则校验码用"X"表示。

  以7-5600-3879-4为例，它的前9位数是7、5、6、0、0、3、8、7、9。它的校验码的计算如下：

  1x7+2x5+3x6+4x0+5x0+6x3+7x8+8x7+9x9
  = 7+10+18+0+0+18+56+56+81
  = 246

  246 % 11 = 4

  因此，这个ISBN的校验码就是4。
*/
function validISBN10(isbn) {
  if (isbn.length !== 10) {
    return false;
  }
  let pre = isbn.slice(0, 9);
  let last = 0;
  for (let i = 0; i < pre.length; i++) {
    last += (i + 1) * parseInt(pre[i]);
  }
  last %= 11;
  if (last === 10) {
    last = "X";
  }
  if (isbn.slice(-1) == last) {
    return true;
  } else {
    return false;
  }
}

// 将用户输入的ISBN-10字符串转化为ISBN-13字符串

/* 转化方法
  1. 将ISBN-10的最后一位校验位去掉，剩下前九个数字。
  2. 在字符串开头增加978三个数字，获得长度为12的数字字符串。
  3. 计算最后一位校验位。

  13位ISBN的校验码计算规则是这样的：前12位数依次乘以1和3，然后求它们的和除以10的余数，最后用10减去这个余数，就得到了校验码。如果余数为0，则校验码为0.

  比如，7-5600-3879-4在13位ISBN中，就是978-7-5600-3879-4。它的校验码计算方法如下：

  9x1+7x3+8x1+7x3+5x1+6x3+0x1+0x3+3x1+8x3+7x1+9x3
  = 9+21+8+21+5+18+0+0+3+24+7+27
  = 143
  
  143 % 10 = 3
  10 - 3 = 7
*/
function ISBN10To13(isbn) {
  let pre = "978" + isbn.slice(0, 9);
  let last = 0;
  for (let i = 0; i < pre.length; i++) {
    if (i % 2 === 0) {
      last += parseInt(pre[i]);
    } else {
      last += parseInt(pre[i]) * 3;
    }
  }
  pre += last % 10 !== 0 ? 10 - (last % 10) : 0;
  return pre;
}

// 测试用例
console.log(getNumbers("7-5600-3879-4")); // 7560038794
console.log(getNumbers("7 5600 3879 4")); // 7560038794

console.log(validISBN10("7560038794")); // true
console.log(validISBN10("7560038793")); // false
console.log(validISBN10("756003879")); // false
console.log(validISBN10("756003879004")); // false

console.log(isbn10To13("7560038794")); // 9787560038797
console.log(isbn10To13("3598215088")); // 9783598215087

```

### 9. 十四届国赛抢红包了

```js
function randomAllocation(total, n) {
  var remain = total;
  var ret = []; // 最终返回的数据

  // 分配金额循环 n-1 次
  for (let i = 0; i < n - 1; i++) {
    // m 为每次分配的红包金额，取 0.1 和 remain 中间的随机数
    let m =
      Math.ceil(Math.random() * 100 * (remain - (n - (i + 1)) * 0.01)) / 100;
    ret.push(m);
    remain -= m; // 剩余量每次减去 M
  }
  ret.push(Number(remain.toFixed(2)));
  return ret;
}
```
### 10. 十四届国赛版本比较器

```js
function compareVersion(version1, version2) {
  const regex = /^\d+(\.\d+){0,2}$/; // 匹配 1~3 个数字，中间用 . 分隔的正则表达式
  if (!regex.test(version1) || !regex.test(version2)) {
    return "error"; // 如果版本号格式不正确，则返回 "error"
  }

  const v1Arr = version1.split(".").map(Number); // 将 version1 按 . 分隔后，将每个部分转换为数字
  const v2Arr = version2.split(".").map(Number); // 将 version2 按 . 分隔后，将每个部分转换为数字
  const len = Math.max(v1Arr.length, v2Arr.length); // 获取两个版本数组的最大长度

  for (let i = 0; i < len; i++) {
    const v1 = i < v1Arr.length ? v1Arr[i] : 0; // 如果 version1 的长度大于 i，则获取第 i 个部分，否则为 0
    const v2 = i < v2Arr.length ? v2Arr[i] : 0; // 如果 version2 的长度大于 i，则获取第 i 个部分，否则为 0

    if (v1 > v2) {
      return 1; // 如果 version1 大于 version2，则返回 1
    } else if (v1 < v2) {
      return -1; // 如果 version1 小于 version2，则返回 -1
    }
  }
  return 0; // 如果两个版本号相等，则返回 0
}
```

### 高频考点知识点讲解：

1. 递归函数（分数较高的题目中出现，基础较好的学生一定要掌握）

递归函数是指在函数体内调用自身的函数。递归函数通常用于解决可以分解为相同问题的子问题的情况。

```javascript
function isPalindrome(str) {
    if (str.length <= 1) {
        return true;
    }
    if (str[0] !== str[str.length - 1]) {
        return false;
    }
    return isPalindrome(str.slice(1, -1));
}

const text = 'racecar';
console.log(isPalindrome(text)); // 输出 true

```

2. 回调函数 (逻辑较为简单，建议一定要掌握，通常用来处理异步操作)

在一个函数中，传递了函数作为参数，就叫回调函数 。

```javascript
// 模拟异步操作，比如从服务器获取数据
function fetchData(callback) {
    setTimeout(() => {
        const data = "这是从服务器获取的数据";
        callback(data); // 在异步操作完成后调用回调函数，并将数据传递给它
    }, 2000); // 模拟2秒延迟
}

// 回调函数，用于处理从服务器获取的数据
function processData(data) {
    console.log("处理数据:", data);
}

// 调用 fetchData 函数，并传递回调函数作为参数
fetchData(processData);
```

3. 数组方法(重点：会贯穿在很多题目里面进行考察)

数组方法用于在数组上执行各种操作，如添加、删除、遍历等。


```javascript

const array = [1, 2, 3, 4, 5];
array.splice(2, 1, 10); // 从索引2开始，删除一个元素，并插入10
console.log(array); // 输出 [1, 2, 10, 4, 5]

// splice() 方法可以用于删除数组中的元素而不替换它们。下面是一个示例：
const array = [1, 2, 3, 4, 5];
array.splice(2, 1); // 从索引2处删除一个元素
console.log(array); // 输出 [1, 2, 4, 5]

// 使用数组方法过滤出偶数
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const evenNumbers = numbers.filter(num => num % 2 === 0);
console.log(evenNumbers); // 输出 [2, 4, 6, 8, 10]

// 使用数组方法求和
const sum = numbers.reduce((acc, curr) => acc + curr, 0);
console.log(sum); // 输出 55
```

4. 字符串方法

字符串方法用于在字符串上执行各种操作，如查找、替换、分割等。

```javascript
// 使用字符串方法查找子串
const str = "Hello, world!";
console.log(str.indexOf("world")); // 输出 7

// 使用字符串方法替换子串
const newStr = str.replace("world", "JavaScript");
console.log(newStr); // 输出 "Hello, JavaScript!"

// 使用字符串方法分割字符串
const words = str.split(", ");
console.log(words); // 输出 ["Hello", "world!"]
```

5. 随机数

随机数用于生成随机值，通常用于模拟真实世界的情况或增加变化性。

```javascript
// 生成随机整数
const randomNumber = Math.floor(Math.random() * 10) + 1; // 生成 1 到 10 之间的随机整数
console.log(randomNumber);

// 生成随机浮点数
const randomFloat = Math.random() * 10; // 生成 0 到 10 之间的随机浮点数
console.log(randomFloat);
```

6. 二维数组操作(一般会在 20 分以上的题目出现，对逻辑要求较高)

二维数组是由数组组成的数组，可以使用双重循环对其进行操作。

```javascript
// 创建一个二维数组
const matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];

// 访问二维数组元素
console.log(matrix[1][2]); // 输出 6

// 遍历二维数组
for (let i = 0; i < matrix.length; i++) {
    for (let j = 0; j < matrix[i].length; j++) {
        console.log(matrix[i][j]);
    }
}
```
7. 对象的基础操作

以上是关于JavaScript中递归函数、回调函数、数组方法、字符串方法、随机数和二维数组操作的简单示例。
### 总结： 函数封装占分比重  30 - 70 分。题目数量：2 - 4。高频考点：`递归函数` 、`回调函数`、`数组方法`、`字符串方法`、`随机数`、`二维数组`

### 备考建议： 函数封装题目占分比例较高，难度不等，对于简单的函数封装题，一定要争取拿到全部分数，对于复杂的函数封装题，可以根据自己的实际情况和做题时间，争取拿到一些分数。


## 三、DOM 操作题目

### 1. 十三届省赛健身大调查

```js
let placeValuesMap = new Map([
  ["1", "公园"],
  ["2", "健身房"],
  ["3", "户外"],
]);
const males = ["男", "女"];

function formSubmit() {
  var formData = new FormData(myForm);
  let height = formData.get("height");
  let weight = formData.get("weight");
  let male = formData.get("male");
  let places = formData.getAll("place");
  places = places.map((placeValue) => placeValuesMap.get(placeValue));
  placeStr = places.join(",");
  // 表单项隐藏
  quescontent.style.display = "none";
  // 结果项目显示
  result.style.display = "block";
  resultStr = `身高${height}cm，体重 ${weight}kg ，性别 ${males[male]}，会在${placeStr}健身锻炼。`;
  result.innerText += `\r\n${resultStr}`;
}
```

### 2. 十三届省赛请到下一步

```js
/*请修改注释 TODO 的两处代码，其他地方不需要修改*/
var current_form, next_form, previous_form; // 表单域
// 点击下一页的按钮
$(".next").click(function () {
  current_form = $(this).parent();
  next_form = $(this).parent().next();

  // 步骤条的样式改变
  $("#progressbar li").eq($("fieldset").index(next_form)).addClass("active");

  // 显示下一个表单域
  next_form.show();
  // 隐藏当前表
  current_form.hide();
});
// 点击返回按钮
$(".previous").click(function () {
  current_form = $(this).parent();
  previous_form = $(this).parent().prev();
  // 移除样式
  $("#progressbar li")
    .eq($("fieldset").index(current_form))
    .removeClass("active");
  // 显示上一个表单域
  previous_form.show();
  // 隐藏当前表单
  current_form.hide();
});
// 点击提交按钮
$(".submit").click(function () {
  alert("提交成功");
});

```

### 3. 十三届省赛冬奥大抽奖	

```js
let rollTime; // 定义定时器变量用来清除定时器
let time = 0; //  转动次数
let num = -1; //转动后所在的元素索引
let speed = 300; // 轮盘转动速度
let times; // 总转动次数

//  开始按钮点击事件后开始抽奖
$("#start").on("click", function () {
  $("#award").text(""); //清空中奖信息
  times = parseInt(Math.random() * (20 - 30 + 1) + 20, 10); //定义总转动次数，随机20-30次
  rolling();
});
// 按顺序旋转函数
function rolling() {
  time++; //转动次数加1
  clearTimeout(rollTime);
  rollTime = setTimeout(() => {
    window.requestAnimationFrame(rolling); // 进行递归动画
  }, speed);
  num++; // 索引加1
  if (num > 8) {
    // 如果索引大于7 则重置为0 因为奖品共有8项
    num = 1;
  }
  // 给中奖的 li 添加active类  考点：给指定元素添加类
  $(".li" + num)
    .addClass("active")
    .siblings()
    .removeClass("active");
  //  如果转动次数大于总转动次数，则停止转动 并清空计时器
  if (time > times) {
    clearInterval(rollTime);
    console.log(num, "中奖索引");
    console.log($(".li" + num).text());
    // 显示中奖信息 在 #award元素中显示中奖信息 考点
    $("#award").text(`恭喜您抽中了${$(".li" + num).text()}!!!`);
    time = 0;
    num = -1;
    return;
  }
}


```

### 4. 十三届省赛课程列表

```js
let pageSize = 5; // 每页条数
let pageNum = 1; // 默认页码
let pagereuslt; // 接收请求返回的数据
let maxPage; // 最大页数
let pageData; // 当前页显示的数据
// 显示最大页数和当前是第几页
function pagefun(maxPage, pageNum) {
  pagination.innerHTML = `共 ${maxPage}  页，当前 ${pageNum} 页`;
}
// 将数据渲染到页面上
function renderHtml(pageData) {
  list.innerHTML = pageData
    .map((item) => {
      return `<div class="list-group">
						<a href="#" class="list-group-item list-group-item-action">
				   		 	<div class="d-flex w-100 justify-content-between">
				       			<h5 class="mb-1">${item.name}</h5>
					  	 		 <small>${(item.price / 100).toFixed(2)}元</small>
							</div>
							<p class="mb-1">${item.description}</p>
						</a>
				</div>`;
    })
    .join("");
}
// 通过 axios 获取数据
axios.get("./js/carlist.json").then((res) => {
  console.log(res.data);
  pagereuslt = res.data;

  pageData = pagereuslt.slice((pageNum - 1) * pageSize, pageNum * pageSize);
  renderHtml(pageData);
  maxPage = Math.ceil(pagereuslt.length / pageSize);
  pagefun(maxPage, pageNum);
});
// 点击获取下一页数据
prev.onclick = function () {
  next.classList.remove("disabled");
  pageNum = pageNum - 1;
  console.log(pagnum);
  if (pageNum <= 1) {
    prev.classList.add("disabled");
    pageNum = 1;
  }
  pageData = pagereuslt.slice((pageNum - 1) * pageSize, pageNum * pageSize);
  renderHtml(pageData);
  pagefun(maxPage, pageNum);
};
// 点击下一页
next.onclick = function () {
  prev.classList.remove("disabled");
  pageNum = pageNum + 1;
  if (pageNum >= maxPage) {
    pagnum = maxPage;
    next.classList.add("disabled");
  }
  pageData = pagereuslt.slice((pageNum - 1) * pageSize, pageNum * pageSize);
  renderHtml(pageData);
  pagefun(maxPage, pageNum);
};

```


### 5. 十三届国赛小兔子找胡萝卜

```js
/*点击开始游戏按钮后，
输入步数，
兔子向前移动的步数，
小兔子按照步数开始在绿色格子上跳，
如果踩到炸弹游戏结束，
如果踩到胡萝卜游戏胜利。
否则一直跳。 */
var step = 0; // 标记当前兔子的位置
var position = 0;
// 游戏开始
/*点击开始按钮后，移动按钮显示，开始按钮隐藏 */
function start() {
  $("#move").css("display", "block");
  $("#start").css("display", "none");
  console.log("游戏开始啦！");
}
// 重置游戏
/*兔子回到初始位置，结果清空，输入框清空，显示开始和移动按钮 */
function reset() {
  console.log("重置游戏！");
  $(".lawn").removeClass("active");
  $("#reset").css("display", "none");
  $("#start").css("display", "block");
  $("p").text("");
  $("input").val("");
  $(".lawn:first-child").addClass("active");
  step = 0;
}
// 移动
/*在输入框中，输入 1 或者 2 可以移动 */
function move() {
  var num = parseInt($("input").val());
  console.log("步数" + num);
  // 判断当前步数是否为 1 或者 2
  if (num == 1 || num == 2) {
    if (num + step == 12) {
      console.log("哎呀！兔子踩到炸弹了，游戏结束！");
      $("p").text("哎呀！兔子踩到炸弹了，游戏结束！");
      $("#reset").css("display", "block");
      $("#move").css("display", "none");
    }
    if (num + step == 23) {
      console.log("小兔子吃到胡萝卜啦，游戏获胜！");
      $("p").text("小兔子吃到胡萝卜啦，游戏获胜！");
      $("#reset").css("display", "block");
      $("#move").css("display", "none");
    }
    if (num + step < 24) {
      $(".lawn")
        .eq(num + step)
        .addClass("active")
        .siblings()
        .removeClass("active");
      step += num;
    }
  } else {
    $("p").text("输入的步数不正确，请重新输入。");
  }
}

```

### 6. 十三届国赛水果消消乐

```js
var foundImage = 0; // 发现的图片
var score = 0; // 当前分数
var images = []; // 放置当前被点击元素的 id
/*点击开始后，格子上的图片会显示出来 */
function startGame() {
  $(".img-box img").show(1000, function () {
    $(this).hide(1000);
  });
  // 隐藏开始按钮
  $("#start").css("visibility", "hidden");
  /* 点击的格子，显示图片，判断点击对象是否为同一图片，是的话不隐藏*/
  $(".img-box").bind("click", function () {
    var id = $(this).children().attr("id"); // 获取被点击图片的 id
    images.push(id); // 将 id 放入数组中
    // 判断当前点击的 img 元素是否隐藏，隐藏则让它显示到页面上
    if ($(this).children().is(":hidden")) {
      $(this).children().show();
      console.log($(this.children));
    } else {
      // 如果当前点击的元素已经显示到页面上，从数组删除重复的 id
      images.pop(id);
      console.log("图片已经显示了。" + images);
    }
    // 如果当前页面上显示的 img 元素有 2 个了，比较两者是否相同
    if (images.length == 2) {
      setTimeout(compare, 500);
    }
    if (foundImage == 16) {
      $("#result").text("游戏结束，你的最终得分为：" + score);
    }
  });
}
// 比较两张图片是否相同
function compare() {
  if ($("#" + images[0]).attr("src") == $("#" + images[1]).attr("src")) {
    console.log("图片相等，消除它们");
    score += 2; // 分数累加
    $("#score").text(score);
    // 隐藏位置
    $("#" + images[0])
      .parent()
      .css("visibility", "hidden");
    $("#" + images[1])
      .parent()
      .css("visibility", "hidden");
    images = [];
    foundImage += 2;
  } else {
    console.log(score);
    score -= 2; // 不相等减分
    $("#score").text(score);
    $("#" + images[0]).hide();
    $("#" + images[1]).hide();
    console.log("不相等，隐藏它们");
    images = [];
  }
}

```

### 7. 十三届国赛新增地址

```js
// 初始化省份下拉列表内容
function provinceInit() {
  var province = document.getElementById("param_province");
  province.length = provinces.length;
  for (var i = 0; i < provinces.length; i++) {
    province.options[i].text = provinces[i];
    province.options[i].value = provinces[i];
  }
}

// 选择省份后对应城市下拉列表内容渲染
function provincechange() {
  var province = document.getElementById("param_province");
  var num = province.selectedIndex; // 选中 option 索引
  var city = document.getElementById("param_city");
  var citystemp = citys[num];
  city.length = citystemp.length;
  for (var i = 0; i < citystemp.length; i++) {
    city.options[i].text = citystemp[i];
    city.options[i].value = citystemp[i];
  }
  city.options[0].selected = true;
}

/**
 * 为标签绑定单击事件。
 * 事件效果为：
 * 1、鼠标点击该标签后该标签样式显示 class=active；
 * 2、其他已选标签的 active 样式被移除；
 * 3、将选中的标签对应下标（即选择器为 “mark a” 选中的标签对应的下标）更新到 id=param_mark 的隐藏的 input 中。
 */
function addClick() {
  var markList = document.querySelectorAll(".mark a");
  for (var i = 0; i < markList.length; i++) {
    (function (index) {
      markList[i].onclick = function () {
        this.className = "active";
        for (var j = 0; j < markList.length; j++) {
          if (j != index) {
            markList[j].className = "";
          }
        }
        document.getElementById("param_mark").value = index;
      };
    })(i);
  }
}
// 提交信息后，读取并显示在页面中
function saveInfo() {
  var province = document.getElementById("param_province").value;
  var city = document.getElementById("param_city").value;
  var address = document.getElementById("param_address").value;
  var mark = document.getElementById("param_mark").value;
  var name = document.getElementById("param_name").value;
  var phone = document.getElementById("param_phone").value;

  if (!province || !city || !address || !name || !phone) {
    document.querySelector(".warning-dialog").style.display = "block";
    return false;
  }

  document.getElementById("main_title").innerHTML = "地址管理";
  document.querySelector(".address").style.display = "none";
  document.querySelector(".user-info").style.display = "none";

  var markClass = "";
  var markInfo = "";
  switch (mark) {
    case "0":
      markClass = "home";
      markInfo = "家";
      break;
    case "1":
      markClass = "company";
      markInfo = "公司";
      break;
    case "2":
      markClass = "school";
      markInfo = "学校";
      break;
  }

  var addressInfoStr = `<li>
    <div class="show-area">
      ${markInfo ? `<label class="${markClass}">${markInfo}</label>` : ""}
      <span>${province + city}</span>
    </div>
    <div class="show-address">
      <span>${address}</span>
      <a><img src="./images/edit.png" /></a>
    </div>
    <div class="show-info">
      <span>${name}</span>
      <span>${phone}</span>
    </div>
  </li>`;
  document.querySelector(".address-list").innerHTML =
    addressInfoStr + document.querySelector(".address-list").innerHTML;
  document.querySelector(".address-list").style.display = "block";
}

// 切换新增地址和地址管理的显隐
function back() {
  if (document.getElementById("main_title").innerHTML == "地址管理") {
    document.getElementById("main_title").innerHTML = "新增地址";
    document.querySelector(".address-list").style.display = "none";
    document.querySelector(".address").style.display = "block";
    document.querySelector(".user-info").style.display = "block";
  }
}
// 页面加载后的初始化操作
function init() {
  // 初始化省份下拉列表内容
  provinceInit();
  // 为标签绑定单击事件
  addClick();
}

window.onload = function () {
  // 初始化
  init();
};

```

### 8. 十三届国赛权限管理	

```js
$(function () {
  // 使用 ajax 获取 userList.json 数据并渲染到页面
  getData();

  // 为按钮添加事件
  $("#add").click(function () {
    var $selectedOpt = $("#leftSelect option:selected");
    var $remove = $selectedOpt.remove();
    $remove.prop("selected", false).appendTo("#rightSelect");
    changeAccess(true, $remove);
  });
  $("#addAll").click(function () {
    var $removeAll = $("#leftSelect option").remove();
    $removeAll.appendTo("#rightSelect");
    changeAccess(true, $removeAll);
  });
  $("#remove").click(function () {
    var $selectedOpt = $("#rightSelect option:selected");
    var $remove = $selectedOpt.remove().appendTo("#leftSelect");
    changeAccess(false, $remove);
  });
  $("#removeAll").click(function () {
    var $removeAll = $("#rightSelect option").remove();
    $removeAll.appendTo("#leftSelect");
    changeAccess(false, $removeAll);
  });
});

// 修改权限
function changeAccess(right, changeList) {
  changeList.each(function (i, item) {
    $("td:nth-child(1)").each(function (j, tdEl) {
      if (item.innerText == tdEl.innerText) {
        $(tdEl)
          .next()
          .html(right ? "管理员" : "普通用户");
      }
    });
  });
}
// 异步获取数据
function getData() {
  $.ajax({
    url: "./js/userList.json",
    method: "get",
    success: (res) => {
      console.log(res);
      var str = $("#userList>tbody").html();
      res.forEach((item) => {
        str += `<tr>
          <td>${item.name}</td>
          <td>${item.right ? "管理员" : "普通用户"}</td>
        </tr>`;
      });
      $("#userList>tbody").html(str);
    },
  });
}

```

### 9. 十三届国赛一起会议吧

```js
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>一起会议吧</title>
    <link rel="stylesheet" type="text/css" href="./css/index.css" />
    <link rel="stylesheet" href="./css/iconfont/iconfont.css" />
  </head>
  <body>
    <div id="app">
      <!-- 登录/注销窗口 -->
      <div class="login">
        <div class="left-tools">
          <a class="close-btn"></a>
          <a class="shrink-btn"></a>
        </div>
        <h3>{{isLogin?'注销':'登录'}}</h3>
        <p v-if="!isLogin">
          选择用户：<select v-model="userId" id="selectUser">
            <option
              v-for="user in defaultUserList"
              :key="user.id"
              :value="user.id"
            >
              {{user.name}}
            </option>
          </select>
        </p>
        <p v-else>当前用户为：{{loginUser&&loginUser.name}}</p>

        <a class="login-btn" @click="isLogin?logout():login()"
          >{{isLogin?'注销':'登录'}}</a
        >
      </div>

      <!-- 右侧显示用户列表窗口按钮 -->
      <button
        id="show"
        v-show="isLogin&&!isShowList"
        class="right-btn"
        @click="isShowList = true"
      >
        <span class="iconfont icon-left-arrow"></span>
      </button>

      <!-- 用户列表窗口 -->
      <div v-show="loginUser&&isLogin&&isShowList" class="user-dialog">
        <!-- 用户列表窗口上侧工具栏 -->
        <ul class="tools">
          <li class="tools-left">
            <button
              :class="[listStatus==1?'active':'']"
              @click="listStatus = 1"
            >
              <span class="iconfont icon-close"></span>
            </button>
            <button
              :class="[listStatus==2?'active':'']"
              @click="listStatus = 2"
            >
              <span class="iconfont icon-dialog"></span>
            </button>
            <button
              :class="[listStatus==3?'active':'']"
              @click="listStatus = 3"
            >
              <span class="iconfont icon-list"></span>
            </button>
          </li>
          <li class="tools-right">
            <button class="show-list" @click="isShowList = false">
              <span class="iconfont icon-retract"></span>
            </button>
          </li>
        </ul>

        <!-- 用户列表 -->
        <ul class="say-list">
          <li>
            <span class="iconfont icon-microphone"></span>
          </li>
          <li class="line"></li>
          <li>正在讲话：Tom；</li>
        </ul>
        <ul v-if="userList.length>0" class="user-list" v-show="listStatus != 1">
          <li v-show="listStatus==2">
            <img class="header" :src="userList[0].imgPath" />
            <div class="user-name">
              <span
                v-if="userList[0].isHost"
                class="iconfont icon-user header-icon"
              ></span>
              <span class="iconfont icon-microphone"></span>
              {{userList[0].name}}
            </div>
          </li>
          <li v-show="listStatus==3" v-for="user in userList" :key="user.id">
            <img class="header" :src="user.imgPath" />
            <div class="user-name">
              <span
                v-if="user.isHost"
                class="iconfont icon-user header-icon"
              ></span>
              <span class="iconfont icon-microphone"></span>
              {{user.name}}
            </div>
          </li>
        </ul>
      </div>
    </div>
    <script type="text/javascript" src="./js/vue.js"></script>
    <script type="text/javascript" src="./js/axios.min.js"></script>
    <script type="text/javascript">
      new Vue({
        el: "#app",
        data: {
          userList: [], // 用户列表
          isLogin: false, // 是否登录
          listStatus: 2, // 1：不显示列表；2：显示列表第一位用户；3：显示列表所有用户；4：收起列表窗口。
          defaultUserList: [],
          userId: "",
          isShowList: true, // 是否显示弹窗
        },
        mounted() {
          axios({
            url: "./js/userList.json",
            method: "get",
          }).then((res) => {
            this.defaultUserList = this.userList = res.data;
            this.userId = this.userList[0].id;
          });
        },
        computed: {
          loginUser() {
            let loginUser = null;
            this.userList.forEach((user) => {
              if (user.id == this.userId) {
                loginUser = user;
              }
            });
            return loginUser;
          },
        },
        methods: {
          login() {
            this.userList.forEach((user, i) => {
              if (user.id == this.loginUser.id) {
                this.userList.unshift(user);
                this.userList.splice(i + 1, 1);
              }
            });
            this.isLogin = true;
          },
          logout() {
            this.isLogin = false;
          },
        },
      });
    </script>
  </body>
</html>

```

### 10. 十四届省赛图片水印生成	

- 考察： dom 操作、css 、 css3 常⻅属性

```js
// 通过 for 循环⽣成指定数量的 span 元素，并将它们添加到容器中
for (let index = 0; index < count; index++) {
  // 使⽤传⼊的参数设置 span 元素的⽂本内容、颜⾊、旋转⻆度和透明度，并添加到容器中
  container.innerHTML += `<span style="color:${color};transform: rotate(${deg}deg);opacity:${opacity}">${text}</span>`;
  // 返回添加了 span 元素的容器
}
```

答案 2 ：

```js
// 使⽤ repeat() ⽅法创建⼀个包含指定数量 span 元素的字符串，并为每个元素设置⽂本内容、颜⾊、旋转⻆度和
const spans =
  `<span style="color:${color};transform: rotate(${deg}deg);opacity:${opacity}">${text}</span>`.repeat(count);
// 将包含所有 span 元素的字符串添加到容器中
container.innerHTML = spans;
// 返回添加了 span 元素的容器
return container;
```
### 10. 十四届省赛年度明星项目	

```js
let translation = {};
const data = [];
// 记录当前展示的项目数量
let cursor = 15;
// 记录当前语言
let currLang = "zh-cn";

// 请求项目数据，展示前50个
$.ajax({
  url: "./js/all-data.json",
  success: (result) => {
    data.push(...result);
    data.slice(0, 15).forEach((item) => {
      $(".list > ul").append(
        createItem({ ...item, description: item.descriptionCN })
      );
    });
  },
});

// 请求翻译数据
$.ajax({
  url: "./js/translation.json",
  success: (result) => {
    translation = result;
  },
});

// 用户点击加载更多时
$(".load-more").click(() => {
  console.log(data.length);
  if (cursor < data.length) {
    data.slice(cursor, (cursor += 15)).forEach((item) => {
      $(".list > ul").append(
        createItem({
          ...item,
          description:
            currLang === "zh-cn" ? item.descriptionCN : item.descriptionEN,
        })
      );
    });
  }
  if (cursor === data.length) {
    $(".load-more").hide();
  }
});

$(".lang").click(() => {
  if (currLang === "en") {
    $(".lang").text("English");
    currLang = "zh-cn";
  } else {
    $(".lang").text("中文");
    currLang = "en";
  }
  $(".list > ul").empty();
  data.slice(0, cursor).forEach((item) => {
    $(".list > ul").append(
      createItem({
        ...item,
        description:
          currLang === "zh-cn" ? item.descriptionCN : item.descriptionEN,
      })
    );
  });
  $("body")
    .find("*")
    .each(function () {
      const text = $(this).text().trim();
      if (translation[text]) {
        $(this).text(translation[text]);
      }
    });
});

function createItem({ name, description, tags, stars, icon }) {
  return `
    <li class="item">
      <img src="images/${icon}" alt="">
      <div class="desc">
        <h3>${name}</h3>
        <p>${description}</p>
        <ul class="labels">
          ${tags.map((tag) => `<li>${tag}</li>`).join("")}
        </ul>
      </div>
      <div class="stars">
        +${stars} 🌟
      </div>
    </li>
  `;
}

```
### 11. 十四届省赛视频弹幕	

```js
const bullets = [
  "前方高能",
  "原来如此",
  "这么简单",
  "学到了",
  "学费了",
  "666666",
  "111111",
  "workerman",
  "学习了",
  "别走，奋斗到天明",
];

/**
 * @description 根据 bulletConfig 配置在 videoEle 元素最右边生成弹幕，并移动到最左边，弹幕最后消失
 * @param {Object} bulletConfig 弹幕配置
 * @param {Element} videoEle 视频元素
 * @param {boolean} isCreate 是否为新增发送的弹幕，为 true 表示为新增的弹幕
 *
 */
function renderBullet(bulletConfig, videoEle, isCreate = false) {
  const spanEle = document.createElement("SPAN");
  spanEle.classList.add(`bullet${index}`);
  if (isCreate) {
    spanEle.classList.add("create-bullet");
  }
  // TODO：控制弹幕的显示颜色和移动，每隔 bulletConfig.time 时间，弹幕移动的距离  bulletConfig.speed
  spanEle.innerText = bulletConfig.value;
  const { width: videoEleWidth, height: videoEleHeight } =
    getEleStyle(videoEle);
  let color = `RGB(${getRandomNum(255)},${getRandomNum(255)}, ${getRandomNum(
    255
  )})`;

  spanEle.style.left = `${videoEleWidth}px`;
  spanEle.style.top = `${getRandomNum(videoEleHeight - 100).toFixed(2)}px`;
  spanEle.style.color = color;

  let spanEleLeft = videoEleWidth;
  videoEle.appendChild(spanEle);
  const { width: spanEleWidth } = getEleStyle(spanEle);
  let timer = setInterval(() => {
    spanEleLeft -= bulletConfig.speed;
    spanEle.style.left = `${
      spanEleLeft + spanEleWidth >= 0 ? spanEleLeft : 0
    }px`;
    if (bulletConfig.isHide || spanEleLeft + spanEleWidth < 0) {
      videoEle.removeChild(spanEle);
      clearInterval(timer);
    }
  }, bulletConfig.time);
}

document.querySelector("#sendBulletBtn").addEventListener("click", () => {
  // TODO:点击发送按钮，输入框中的文字出现在弹幕中
  bulletConfig.value = document.querySelector("#bulletContent").value;
  if (isPlay && bulletConfig.value != "") {
    renderBullet(bulletConfig, videoEle, true);
  }
  document.querySelector("#bulletContent").value = "";
});

function getEleStyle(ele) {
  // 获得元素的width,height,left,right,top,bottom
  return ele.getBoundingClientRect();
}

function getRandomNum(end, start = 0) {
  // 获得随机数，范围是 从start到 end
  return Math.floor(start + Math.random() * (end - start + 1));
}

// 设置 index 是为了弹幕数组循环滚动
let index = 0;
const videoEle = document.querySelector("#video");
// 弹幕配置
const bulletConfig = {
  isHide: false, // 是否隐藏
  speed: 5, // 弹幕的移动距离
  time: 50, // 弹幕每隔多少ms移动一次
};
let isPlay = false;
let timer;
document.querySelector("#vd").addEventListener("play", () => {
  isPlay = true;
  bulletConfig.value = bullets[index++];
  renderBullet(bulletConfig, videoEle);
  timer = setInterval(() => {
    bulletConfig.value = bullets[index++];
    renderBullet(bulletConfig, videoEle);
    if (index >= bullets.length) {
      index = 0;
    }
  }, 1000);
});

document.querySelector("#vd").addEventListener("pause", () => {
  isPlay = false;
  clearInterval(timer);
});

document.querySelector("#switchButton").addEventListener("change", (e) => {
  if (e.target.checked) {
    bulletConfig.isHide = false;
  } else {
    bulletConfig.isHide = true;
  }
});

```
### 12. 十四届省赛组课神器
```js
/**
 * @description 模拟 ajax 请求，拿到树型组件的数据 treeData
 * @param {string} url 请求地址
 * @param {string} method 请求方式，必填，默认为 get
 * @param {string} data 请求体数据，可选参数
 * @return {Array}
 * */
async function ajax({ url, method = "get", data }) {
  let result;
  // TODO：根据请求方式 method 不同，拿到树型组件的数据
  // 当method === "get" 时，localStorage 存在数据从 localStorage 中获取，不存在则从 /js/data.json 中获取
  // 当method === "post" 时，将数据保存到localStorage 中
  if (method === "get") {
    let res;
    if (localStorage.getItem("data")) {
      result = JSON.parse(localStorage.getItem("data"));
    } else {
      data = await axios({ url, method, data });
      res = data.data;
      result = res.data;
    }
  }
  if (method === "post") {
    localStorage.setItem("data", JSON.stringify(data));
  }
  return result;
}

/**
 * @description 找到元素节点的父亲元素中类选择器中含有 tree-node 的元素节点
 * @param {Element} node 传入的元素节点
 * @return {Element} 得到的元素节点
 */
const getTreeNode = (node) => {
  let curElement = node;
  while (!curElement.classList.contains("tree-node")) {
    if (curElement.classList.contains("tree")) {
      break;
    }
    curElement = curElement.parentNode;
  }
  return curElement;
};

/**
 * @description 根据 dragElementId, dropElementId 重新生成拖拽完成后的树型组件的数据 treeData
 * @param {number} dragGrade 被拖拽的元素的等级，值为 dragElement data-grade属性对应的值
 * @param {number} dragElementId 被拖拽的元素的id，值为当前数据对应在 treeData 中的id
 * @param {number} dropGrade 放入的目标元素的等级，值为 dropElement data-grade属性对应的值
 * @param {number} dropElementId 放入的目标元素的id，值为当前数据对应在 treeData 中的id
 */
function treeDataRefresh(
  { dragGrade, dragElementId },
  { dropGrade, dropElementId }
) {
  if (dragElementId === dropElementId) return;
  // TODO：根据 `dragElementId, dropElementId` 重新生成拖拽完成后的树型组件的数据 `treeData`
  const getAndDeleteDragLabelObj = (dragElementId, data) => {
    let result;
    if (dragGrade - dropGrade > 1 || dragGrade - dropGrade < 0) return result;
    const innerFn = (dragElementId, data) => {
      data.forEach((treeObj, index, array) => {
        if (treeObj.id === Number(dragElementId)) {
          array.splice(index, 1);
          result = treeObj;
        } else {
          treeObj.children && innerFn(dragElementId, treeObj.children);
        }
      });
    };
    innerFn(dragElementId, data);
    return result;
  };
  const setDragLabelObjToTreeData = (dragLabelObj, dropElementId, data) => {
    for (let i = 0; i < data.length; i++) {
      const treeObj = data[i];
      if (treeObj.id === Number(dropElementId)) {
        if (dragGrade - dropGrade == 1) {
          treeObj.children
            ? treeObj.children.unshift(dragLabelObj)
            : (treeObj["children"] = [dragLabelObj]);
        } else if (dragGrade - dropGrade == 0) {
          data.splice(i + 1, 0, dragLabelObj);
          break;
        }
      } else {
        treeObj.children &&
          setDragLabelObjToTreeData(
            dragLabelObj,
            dropElementId,
            treeObj.children
          );
      }
    }
  };
  let dragLabelObj = getAndDeleteDragLabelObj(dragElementId, treeData);
  if (dropElementId) {
    dragLabelObj &&
      setDragLabelObjToTreeData(dragLabelObj, dropElementId, treeData);
  } else {
    treeData.unshift(dragLabelObj);
  }
}

/**
 * @description 根据 treeData 的数据生成树型组件的模板字符串，在包含 .tree-node 的元素节点需要加上 data-grade=${index}表示菜单的层级 data-index="${id}" 表示菜单的唯一id
 * @param {array} data treeData 数据
 * @param {number} grade 菜单的层级
 * @return 树型组件的模板字符串
 *
 * */
function treeMenusRender(data, grade = 0) {
  let treeTemplate = "";
  // TODO：根据传入的 treeData 的数据生成树型组件的模板字符串
  grade++;
  return data.reduce((prev, cur) => {
    let isContainChild = !!cur.children;
    return (treeTemplate += `
        <div class="tree-node"  data-grade=${grade} data-index="${cur.id}">
            <div class="tree-node-content" style="margin-left:${
              (grade - 1) * 15
            }px">
                <div class="tree-node-content-left">
                    <img src="https://static.shiyanlou.com/opcenter-fe/frontend/dist/img/icon-dragger.2c0734b.svg"  class="point-svg">
                    ${
                      cur.tag
                        ? `<span class="tree-node-tag" >${cur.tag}</span>`
                        : ""
                    }
                    <span class="tree-node-label">${cur.label}</span>
                    ${
                      isContainChild
                        ? `<img class="config-svg" src="https://static.shiyanlou.com/opcenter-fe/frontend/dist/img/icon-setting.4ab65af.svg">`
                        : ""
                    }
                </div>

                ${
                  !isContainChild
                    ? `<div class="tree-node-content-right">
                        <div class="students-count">
                            <span class="number">0人完成</span>
                            <span class="line">|</span>
                            <span class="number">0人提交报告</span>
                        </div>
                        <div class="config">
                            <img class="config-svg"
                                src="https://static.shiyanlou.com/opcenter-fe/frontend/dist/img/icon-setting.4ab65af.svg"
                                alt="">
                            <button class="doc-link">编辑文档</button>
                        </div>
                    </div>`
                    : ""
                }
            </div>
            ${
              isContainChild
                ? `<div class="tree-node-children">
                    ${isContainChild && treeMenusRender(cur.children, grade)}
                </div>`
                : ""
            }
        </div>    
        `);
  }, "");
}

let treeData; // 树型组件的数据 treeData

// 拖拽到目标元素放下后执行的函数
const dropHandler = (dragElement, dropElement) => {
  let dragElementId = dragElement.dataset.index;
  let dragGrade = dragElement.dataset.grade;
  if (dropElement) {
    let dropElementId = dropElement.dataset.index;
    let dropGrade = dropElement.dataset.grade;

    treeDataRefresh({ dragGrade, dragElementId }, { dropGrade, dropElementId });
    document.querySelector(".tree").innerHTML = treeMenusRender(treeData);
    document.querySelector("#test").innerText = treeData
      ? JSON.stringify(treeData)
      : "";
    ajax({ url: "./js/data.json", method: "post", data: treeData });
  }
};
// 初始化
ajax({ url: "./js/data.json" }).then((res) => {
  treeData = res;
  document.querySelector("#test").innerText = treeData
    ? JSON.stringify(treeData)
    : "";
  let treeEle = document.querySelector(".tree");
  treeEle.dataset.grade = 0;
  let treeTemplate = treeMenusRender(treeData);
  treeTemplate && (treeEle.innerHTML = treeTemplate);
  const mDrag = new MDrag(".tree-node", dropHandler);
  // 事件委托，按下小图标记录得到被拖拽的元素，该元素 class 包含 .tree-node
  document.querySelector(".tree").addEventListener("mousedown", (e) => {
    e.preventDefault();
    if (
      e.target.nodeName.toLowerCase() === "img" &&
      e.target.classList.contains("point-svg")
    ) {
      let dragElement = getTreeNode(e.target);
      // MDrag类的drag方法实现拖拽效果
      mDrag.drag(e, dragElement);
    }
  });
});

/**
 * @description 实现拖拽功能的类，该类的功能为模拟 HTML5 drag 的功能
 *              鼠标按下后，监听 document 的 mousemove 和 mouseup 事件
 *              当开始拖拽一个元素后会在 body 内插入对应的克隆元素，并随着鼠标的移动而移动
 *              鼠标抬起后，移除克隆元素和 mousemove 事件，如果到达目标触发传入的 dropHandler 方法
 */
class MDrag {
  constructor(dropElementSelector, dropHandler) {
    // 目标元素的选择器
    this.dropElementSelector = dropElementSelector;
    // 拖拽到目标元素放下后执行的函数
    this.dropHandler = dropHandler;

    // 保存所有的目标元素
    this.dropBoundingClientRectArr = [];
    // 被拖拽的元素
    this._dragElement = null;
    // 拖拽中移动的元素
    this._dragElementClone = null;
    // 目标元素
    this._dropElement = null;
    // 拖拽移动事件
    this._dragMoveBind = null;
    // 拖拽鼠标抬起事件
    this._dragUpBind = null;

    this.init();
  }
  init() {
    const dropElements = document.querySelectorAll(this.dropElementSelector);
    this.dropBoundingClientRectArr = Array.from(dropElements).map((el) => {
      return { boundingClientRect: el.getBoundingClientRect(), el };
    });
  }
  dragMove(e) {
    const { pageX, pageY } = e;
    this._dragElementClone.style.left = `${e.pageX}px`;
    this._dragElementClone.style.top = `${e.pageY}px`;
    this.setMouseOverElementStyle(pageX, pageY);
  }
  dragend(e) {
    // 移动到目标元素后mouseup事件触发，删除 this._dragElementClone 元素和解除mousemove/mouseup事件
    const { pageX, pageY } = e;
    document.removeEventListener("mousemove", this._dragMoveBind);
    document.removeEventListener("mouseup", this._dragUpBind);
    if (
      Array.from(document.body.children).indexOf(this._dragElementClone) != -1
    ) {
      document.body.removeChild(this._dragElementClone);
    }
    this._dropElement = this.getActualDropElement(pageX, pageY);
    this.drop();
  }
  drag(e, dragElement) {
    this._dragElement = dragElement;
    this._dragElementClone = dragElement.cloneNode(true);
    this._dragElementClone.style.position = "absolute";
    this._dragElementClone.style.left = `${e.pageX - 20}px`;
    this._dragElementClone.style.top = `${e.pageY - 20}px`;
    this._dragElementClone.style.opacity = 0.5;
    this._dragElementClone.style.width = "800px";
    document.body.appendChild(this._dragElementClone);
    // 绑定mousemove和mouseup事件
    this._dragMoveBind = this.dragMove.bind(this);
    this._dragUpBind = this.dragend.bind(this);
    document.addEventListener("mousemove", this._dragMoveBind);
    document.addEventListener("mouseup", this._dragUpBind);
    return this;
  }
  getActualDropElement(pageX, pageY) {
    const dropAttributeArr = this.dropBoundingClientRectArr.filter(
      (obj) =>
        pageY >= obj.boundingClientRect.top &&
        pageY <= obj.boundingClientRect.top + obj.boundingClientRect.height
    );
    if (dropAttributeArr.length == 1) {
      return dropAttributeArr[0].el;
    } else if (dropAttributeArr.length > 1) {
      let temp = dropAttributeArr.reduce((prev, next) => {
        if (
          Math.abs(pageY - prev.boundingClientRect.top) <=
          Math.abs(pageY - next.boundingClientRect.top)
        ) {
          return prev;
        } else {
          return next;
        }
      });
      return temp.el;
    } else {
      return null;
    }
  }
  setMouseOverElementStyle(pageX, pageY) {
    let mousemoveEle = this.getActualDropElement(pageX, pageY);
    if (mousemoveEle) {
      this.dropBoundingClientRectArr.forEach((obj) => {
        obj.el.classList.contains("mouseover-active") &&
          obj.el.classList.remove("mouseover-active");
      });
      mousemoveEle.classList.add("mouseover-active");
    }
  }
  drop() {
    this.dropHandler && this.dropHandler(this._dragElement, this._dropElement);
    this.init();
  }
}
```
### 13. 十四届国赛文本查重小能手
```js
// index.js
let articles;
// 获取 select 下拉元素
const articleSelect = document.getElementById("articleSelect");

// 获取查重按钮元素
const checkPlagiarismEl = document.getElementById("checkPlagiarism");
// 获取原文
const originalText = document.getElementById("originalText").value;
// 获取显示重复率的元素
const plagiarismRateText = document.getElementById("plagiarismRateText");

// 获取对比文章文本框
const compareText = document.getElementById("compareText");

// 请求文章数据
fetch("./data.json")
  .then((response) => response.json())
  .then((res) => {
    articles = res.data;
    compareText.value = articles[`articleOne`];
  })
  .catch((error) => console.error(error));
// 切换文章
articleSelect.addEventListener("change", function () {
  const selectedValue = articleSelect.value;
  compareText.value = articles[`${selectedValue}`];
});

// 点击查重按钮显示重复率

checkPlagiarismEl.addEventListener("click", function () {
  let plagiarismRate = checkPlagiarism(originalText, compareText.value);
  plagiarismRateText.innerHTML = `重复率：${(plagiarismRate * 100).toFixed(
    2
  )}%`;
});
```

```js
const stopWords = new Set(["的", "为", "了", "是", "在", "我", "有", "和", "就", "不", "都", "上", "也", "很", "到", "说", "要", "去", "你", "会", "着", "没有", "看", "好", "自己", "这", "它", "与", "们", "断", "让", "从", "而", "及", "将", "涉", "来"]);

function hasStopWord(word) {
  return word.split("").some((char) => stopWords.has(char));
}

function splitByStopWords(text) {
  // 将字符串分割成单个字符，并存储在一个数组中
  const words = text.split("");
  // 定义一个空数组，用于存储分割后的结果
  const result = [];
  // 定义左指针，初始值为0
  let left = 0;
  // 遍历单个字符的数组，包括最后一个位置的 undefined
  for (let i = 0; i <= words.length; i++) {
    // 如果已经遍历到了数组的最后一个位置，或者当前字符在停用词集合中
    if (i === words.length || stopWords.has(words[i])) {
      // 如果左指针和当前指针不相等，说明当前位置是一个分隔符
      if (left !== i) {
        // 将左指针和当前指针之间的字符连接成一个字符串，并存储在结果数组中
        result.push(words.slice(left, i).join(""));
      }
      // 更新左指针为当前位置的下一个位置
      left = i + 1;
    }
  }
  // 返回分割后的结果数组
  return result;
}

/**
 * @param {Array} words  传入的分词数组
 * @return {Array} 处理后的分词数组
 */
function wordSegmentation(words) {
  words = words
    .replace(/[^\u4e00-\u9fa5]+|\d+/g, " ")
    .split(" ")
    .filter((item) => item !== "");
  const resultWord = [];
  for (const item of words) {
    if (hasStopWord(item)) {
      // 根据停用词继续分词
      let result = splitByStopWords(item);
      resultWord.push(...result);
    } else {
      resultWord.push(item);
    }
  }
  console.log(resultWord, "最终结果");
  return resultWord;
}

/**
 * @param {string} text1 查询文章
 * @param {string} text2 对比文章
 * @return {number} plagiarismRate  相似度
 */
function checkPlagiarism(text1, text2) {
  // 1. 分词
  words1 = wordSegmentation(text1);
  words2 = wordSegmentation(text2);

  // 2.对分词后的原始文本和待比较文本进行去重处理
  const uniqueWords1 = Array.from(new Set(words1)); // 原文分词后的数组
  const uniqueWords2 = Array.from(new Set(words2)); //对照文章分词后的数组

  // 3.统计两篇文章的相同词语数目
  let commonWordsCount = 0;
  uniqueWords1.forEach((word) => {
    if (uniqueWords2.includes(word)) {
      commonWordsCount++;
    }
  });

  // 4.计算重复率
  const plagiarismRate = commonWordsCount / uniqueWords1.length;
  return plagiarismRate;
}

// 检测需要，请勿删除
try {
  module.exports = wordSegmentation;
} catch (e) {}

```
### 14. 十四届国赛恶龙与公主	

```js

let game = {
  element: {
    boxs: document.querySelectorAll(".container .box"),
    bloodEle: document.querySelector("#blood span"),
    tipEle: document.querySelector(".tip"),
    gameCtl: document.querySelector("#control .btn"),
    gameStep: document.querySelector("#control .ctl-input"),
    gamePath: document.querySelector("#game-path"),
  },
  gameData: {
    step: 0,
    dragonPos: [
      1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19, 21, 22, 23,
      24,
    ].filter((i) => Math.random() > 0.8), // 恶龙的位置
    angelPos: 20, // 天使的位置
    randomArr: [
      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
      21, 22, 23, 24,
    ],
    pathArr: [], // 表示行走的路径数组
    curPos: 0, // 表示当前的位置
    curBlood: 3, // 表示当前的血量
  },
  events: {
    moveHandlerDebounce: null,
  },
  randomNum(start, end) {
    return Math.floor(Math.random() * (end - start + 1)) + start;
  },
  getStep(step) {
    return step ? step : Number(this.randomNum(1, 3));
  },
  // 游戏的所有格子的 data-index 属性按照摆放的位置组成二维数组，起始和最中间的格子单独赋值
  getDyadicArray() {
    const dyadicArray = [];
    let tempArr = [];
    Array.from(this.element.boxs).forEach((box, index) => {
      let i = index % 5;
      tempArr.push(Number(box.dataset.index));
      if (i == 4) {
        dyadicArray.push(tempArr);
        tempArr = [];
      }
    });
    dyadicArray[0][0] = "start";
    dyadicArray[2][2] = "end";
    return dyadicArray;
  },
  debounce(handle, isImmediate = false, wait = 500) {
    let timer = null;
    let isDone;
    return function (...args) {
      let self = this;
      isDone = isImmediate && !timer;
      timer && clearTimeout(timer);
      timer = setTimeout(() => {
        timer = null;
        !isImmediate && handle.apply(self, args);
      }, wait);
      isDone && handle.apply(self, args);
    };
  },
  tipRender(tip) {
    const tipEle = this.element.tipEle;
    tipEle.classList.remove("hide");
    tipEle.classList.add("show");
    if (tip === "success") {
      tipEle.style.backgroundColor = "green";
      tipEle.innerText = "营救成功";
    }
    if (tip === "warning") {
      tipEle.style.backgroundColor = "red";
      tipEle.innerText = "重伤不治";
    }
  },
  bloodCalculator(boxEle) {
    curBlood = this.gameData.curBlood;
    if (Array.from(boxEle.classList).includes("dragon")) {
      curBlood -= 2;
    }
    if (Array.from(boxEle.classList).includes("angel")) {
      curBlood += 3;
    }
    if (curBlood <= 0) {
      this.tipRender("warning");
      curBlood = 0;
      this.element.gameCtl.removeEventListener(
        "click",
        this.events.moveHandlerDebounce
      );
    }
    this.element.bloodEle.innerText = curBlood;
    this.gameData.curBlood = curBlood;
  },
  /**
   * @param {array}: getDyadicArray 得到的二维数据，存储地图上每个box的 data-index 值
   * @return {array}: 一维数组，保存经过的路径
   */
  mazePath(arr) {
    // TODO:得到起点到终点经过的每个 box 元素的 data-index 的值并依次保存在数组中
    let bottom = arr.length,
      right = arr[0].length;
    let total = bottom * right;
    const result = [];
    let left = 0,
      top = 0,
      count = 0;
    while (left < right && top < bottom) {
      //l-> r
      for (let j = left; j < right; j++) {
        result.push(arr[top][j]);
        j == right - 1 && top++;
      }
      // t-> b
      for (let i = top; i < bottom; i++) {
        result.push(arr[i][right - 1]);
        i == bottom - 1 && right--;
      }
      // r -> l
      for (let j = right - 1; j >= left; j--) {
        result.push(arr[bottom - 1][j]);
        j == left && bottom--;
      }
      // b -> t
      for (let i = bottom - 1; i >= top; i--) {
        result.push(arr[i][left]);
        i == top && left++;
      }
    }
    console.log(JSON.stringify(result.slice(0, total)));
    return result.slice(0, total);
  },
  moveHandler() {
    let step = (this.element.gameStep.value = this.getStep(this.gameData.step));
    // TODO：根据点击营救后获得的点数，正确到达指定位置调用bloodCalculator函数计算当前血量，到达公主处调用 tipRender 函数，每步的时间间隔在 200ms内（大于此时间会导致判题失败）。
    curPos = this.gameData.curPos;
    let start = curPos;
    curPos += step;
    curPos = curPos >= 24 ? 24 : curPos;
    this.gameData.curPos = curPos;
    for (let i = start; i <= curPos; i++) {
      let timer = setTimeout(() => {
        this.element.boxs.forEach((box) => {
          if (this.gameData.pathArr[i] == box.dataset.index) {
            box.classList.add("active");
            if (i == curPos) {
              this.bloodCalculator(box);
            }
          } else {
            box.classList.remove("active");
          }
        });
        if (i === 24) {
          this.tipRender("success");
        }
        timer !== null && (timer = null);
      }, (i - start) * 200);
    }
  },
  initPlay() {
    Array.from(this.element.boxs).forEach((box, index, boxs) => {
      if (index === 0) {
        box.innerText = "start";
        box.setAttribute("data-index", "start");
      } else if (index === Math.floor(boxs.length / 2)) {
        box.classList.add("princess");
        box.setAttribute("data-index", "end");
      } else {
        box.setAttribute("data-index", this.gameData.randomArr[index]);
        if (this.gameData.dragonPos.includes(index)) {
          box.classList.add("dragon");
        } else if (index == this.gameData.angelPos) {
          box.classList.add("angel");
        } else {
          box.style.backgroundColor = "#f5f5f5";
          box.innerText = `无危险`;
        }
      }
    });
    this.element.bloodEle.innerText = this.gameData.curBlood;
    this.gameData.pathArr = this.mazePath(this.getDyadicArray());
    this.element.gamePath.innerText = JSON.stringify(this.gameData.pathArr);
    this.events.moveHandlerDebounce = this.debounce(
      this.moveHandler.bind(this)
    );
    this.element.gameCtl.addEventListener(
      "click",
      this.events.moveHandlerDebounce
    );
  },
};
```

### 总结： DOM  操作  20 - 50 分。题目数量：1 - 4。高频考点：`class` 操作，获取 dom ，设置 DOM 内容，显示和隐藏，新增 DOM ,删除 DOM 节点。

### 备考建议： DOM 操作题目占分均衡，大部分 DOM 操作题在难度在中等，所有一定要尽量拿分。

### 高频考点知识点讲解：

1. form 表单数据 (必须要掌握的内容)

- `let formData = new FormData(myForm);`：创建了一个 FormData 对象，它用于将表单数据编码成键/值对集合以便于使用。`myForm` 是一个表单元素的引用，用于指定要从哪个表单中获取数据。

- `formData.get('name')` // 获取表单中 name 属性的值


2. `class` 操作（必考点，一定要拿的分数）

```html
<!DOCTYPE html>
<html>
<head>
  <title>Class操作示例</title>
  <style>
    .highlight {
      background-color: yellow;
    }
  </style>
</head>
<body>

<div id="myDiv" class="highlight">这是一个div元素</div>

<script>
  // 切换类名
  document.getElementById("myDiv").classList.toggle("highlight");

  // 替换类名
  document.getElementById("myDiv").classList.replace("highlight", "newHighlight");
</script>

</body>
</html>
```

3. 获取 DOM 元素、设置 DOM 内容、显示和隐藏

```html
<!DOCTYPE html>
<html>
<head>
  <title>DOM操作示例</title>
</head>
<body>

<button onclick="changeContent()">改变内容</button>
<div id="myElement">这是一个可改变内容的元素</div>

<script>
  function changeContent() {
    document.getElementById("myElement").innerHTML = "内容已改变！";
  }

  // 显示元素
  document.getElementById("myElement").style.display = "block";

  // 隐藏元素
  document.getElementById("myElement").style.display = "none";
</script>

</body>
</html>
```

4. 新增 DOM

```html
<!DOCTYPE html>
<html>
<head>
  <title>新增DOM示例</title>
</head>
<body>

<div id="container">
  <h2>原始内容</h2>
  <p>这是原始的段落。</p>
</div>

<button onclick="addParagraph()">添加段落</button>

<script>
  function addParagraph() {
    var newParagraph = document.createElement("p");
    var text = document.createTextNode("这是新添加的段落。");
    newParagraph.appendChild(text);

    // 将新段落插入到容器中的第一个子元素之前
    document.getElementById("container").insertBefore(newParagraph, document.getElementById("container").firstChild);
  }
</script>

</body>
</html>
```

5. 删除 DOM 节点

```html
<!DOCTYPE html>
<html>
<head>
  <title>删除DOM示例</title>
</head>
<body>

<div id="container">
  <h2>原始内容</h2>
  <p class="paragraph">这是要删除的段落。</p>
  <p class="paragraph">这是另一个要删除的段落。</p>
</div>

<button onclick="deleteParagraph()">删除第一个段落</button>

<script>
  function deleteParagraph() {
    var elements = document.getElementsByClassName("paragraph");
    if (elements.length > 0) {
      elements[0].parentNode.removeChild(elements[0]);
    }
  }
</script>

</body>
</html>
```

这些示例演示了更多的 `class` 操作、获取 DOM 元素、设置 DOM 内容、显示和隐藏、新增 DOM、删除 DOM 节点的方法。

## 四、ES6  题目

### 1. 十三届省赛灯的颜色变化	
### 2. 十四届省赛收集帛书碎片	
### 3. 十四届国赛萌宠小玩家	

### 高频考点知识点讲解：

- Promise:
- class 
- Set
- Map
- 扩展运算符 ... 

1. [收集帛书碎⽚](https://www.lanqiao.cn/problems/5135/learning)

- 考察：数组⽅法、数组去重、扩展运算符 
- 解题思路：⼊参是⼀个⼆维数组，转换成⼀维数组，去重

答案 1 ：

```js
const result = [...new Set(puzzles.flat())];
return result;
```

答案 2 ：

```js
let result = [];
for (let index = 0; index < puzzles.length; index++) {
  const item = puzzles[index];
  result.push(...item);
}
result = [...new Set(result)];
return result;
```

- 知识点解析： `flat()` 是 `JavaScript` 数组的⼀个⽅法，⽤于将多维数组扁平化为⼀维数组。

该⽅法可以接收⼀个整数参数，表示要扁平化的嵌套层数。例如，如果传递参数 2 ，则会将⼆维数组扁 平化为⼀维数组，但不会将三维及以上的数组扁平化。

如果不传递参数，则默认值扁平化⼀层。如果数组中有空位（即未定义的元素），则 `ﬂat()` ⽅法默认会将其删除，返回⼀个新的不含空位的数组。

以下是 `ﬂat()` ⽅法的示例⽤法：

```js
const arr1 = [1, 2, [3, 4]];

arr1.flat(); // [1, 2, 3, 4]

const arr2 = [1, 2, [3, 4, [5, 6]]];

arr2.flat(); // [1, 2, 3, 4, [5, 6]]

const arr3 = [1, 2, [3, 4, [5, 6]]];

arr3.flat(2); // [1, 2, 3, 4, 5, 6]
```

在上⾯的示例中，`arr1` 和 `arr2` 数组中的嵌套数组都被扁平化为了⼀维数组。在 `arr3` 中，`flat(2)` ⽅法将嵌套数组扁平化了两层，⽣成了⼀个包含所有元素的⼀维数组。
`Set` 是 `JavaScrip`t 中的⼀种数据结构，它类似于数组，但是它的值是唯⼀的，不会有重复的值。


在ES6中，"..."（三个连续的点）是一个扩展运算符（Spread Operator）的语法。它有以下几种主要的作用：

- 数组的展开：使用扩展运算符可以将一个数组展开为独立的元素。例如：

```javascript
const arr = [1, 2, 3];
console.log(...arr); // 输出: 1 2 3
```

-  函数调用时的参数传递：扩展运算符可以用于将一个数组作为参数传递给函数，并展开为独立的参数。例如：

```javascript
function sum(a, b, c) {
  return a + b + c;
}

const numbers = [1, 2, 3];
console.log(sum(...numbers)); // 输出: 6
```

- 对象的展开：扩展运算符可以用于将一个对象展开为另一个对象的属性。例如：

```javascript
const obj1 = { x: 1, y: 2 };
const obj2 = { ...obj1, z: 3 };
console.log(obj2); // 输出: { x: 1, y: 2, z: 3 }
```

- 数组和对象的浅拷贝：通过扩展运算符可以创建数组和对象的浅拷贝。例如：

```javascript
const arr = [1, 2, 3];
const arrCopy = [...arr];

const obj = { x: 1, y: 2 };
const objCopy = { ...obj };
```

需要注意的是，扩展运算符只能在可迭代对象（如数组）或具有可枚举属性的对象上使用。它提供了一种方便的方式来处理数组和对象的展开、合并和复制操作，使代码更加简洁和易读。

2. [萌宠小玩家](https://www.lanqiao.cn/courses/18421/learning/?id=911416)

- 考察： `class`、数组、dom 操作

```js
 // 验证是否已经起名
  verifyName() {
    this.name = nickname.value;
    if (!this.name) {
      vail_name.style.display = "block";
    } else {
      vail_name.style.display = "none";
    }
  }
  showLog(record) {
    if (this.logList.length == 10) {
      this.logList.pop();
      this.logList.unshift(record);
    } else {
      this.logList.unshift(record);
      console.log(this.logList);
    }
    let logHtmlStr = this.logList
      .map((item) => {
        return `<div>${item}</div>`;
      })
      .join("");
    list.innerHTML = logHtmlStr;
  }
```

## 五  element-plus 题目

### 1. 十四届省赛外卖给好评


### 2. [十四届国赛 element-ui 轮播图组件二次封装](https://www.lanqiao.cn/courses/18421/learning/?id=855653)

考察：`element-ui` 轮播图组件、vue 基础知识

```html
<template>
  <!-- 省略其他代码... -->
  <li
    class="point"
    v-for="(_, index) in images"
    :key="index"
    :class="{ active: currentIndex === index }"
    @click="setActive(index)"
  ></li>
  <!-- 省略其他代码... -->
</template>

<script>
  data() {
     return {
       currentIndex: 0,
     };
   },
   methods: {
     carouselChange(index) {
       this.currentIndex = index;
     },
     setActive(index) {
       this.$refs.carousel.setActiveItem(index);
     },
   },
</script>
```

### 总结：element-plus 难度一般在中等以下，题目分值占比 10 - 15 分，高频考点：`表单配置`，`基本组件配置` 。

### 备赛建议：element-plus 难度不高，涉及到的 API 官方都会提供，题目分值占比 10 - 15 分，建议作为必拿分题目。


## echarts 题目 

### 1. 十三届省赛和手机相处的时光	

### 2. 十三届国赛 [天气趋势](https://www.lanqiao.cn/problems/2466/learning)

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>天气统计</title>
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"
    />
    <link rel="stylesheet" type="text/css" href="css/style.css" />
    <script src="./js/axios.js"></script>
    <script src="js/vue.min.js" type="text/javascript" charset="utf-8"></script>
    <script
      src="js/echarts.min.js"
      type="text/javascript"
      charset="utf-8"
    ></script>
  </head>

  <body>
    <div id="app">
      <div class="top-bar">2022年Y城全年温度统计图</div>
      <!-- 主体 -->
      <div class="container">
        <!-- 月份 -->
        <div class="month">
          <ul>
            <li
              v-for="(val, key, index) in monthList"
              :class="activeMonth===index+1?'active':''"
              @click="changeMonth(index)"
            >
              {{val}}
            </li>
          </ul>
        </div>
        <!-- 未来七天和本月tab切换框，只有当前月才显示 -->
        <div class="chart">
          <div id="currentMonth" v-if="currentMonth==activeMonth">
            <div class="title">
              <h3>{{typeTitle}}</h3>
              <div class="type">
                <span
                  id="seven"
                  :class="type==1?'active':''"
                  @click="changeType(1)"
                  >未来7天</span
                >
                <span
                  id="current"
                  :class="type==2?'active':''"
                  @click="changeType(2)"
                  >本月</span
                >
              </div>
            </div>
          </div>
          <div id="chart"></div>
        </div>
      </div>
    </div>
  </body>
</html>
<script>
  var vm = new Vue({
    el: "#app",
    data: {
      type: 2, //本月和未来七天type，默认显示本月
      chart: null, // 图表
      chartOptions: null, // 图表配置项
      typeTitle: "本月天气",
      monthList: {
        January: "1月",
        February: "2月",
        March: "3月",
        April: "4月",
        May: "5月",
        June: "6月",
        July: "7月",
        August: "8月",
        September: "9月",
        October: "10月",
        November: "11月",
        December: "12月",
      },
      currentMonth: 0, // 当前月份
      activeMonth: 1, // 点击的月份
      currentDay: null, // 今天
      weatherData: [], // 天气数据
      seriesData: [], // Y 轴坐标数据
      xAxisdata: [], // x轴坐标数据
      months: [], // 把月份放进一个数组方便取数据
    },
    async created() {
      this.weatherData = await axios
        .get("./js/weather.json")
        .then((res) => res.data);
      //设置月份数组
      for (let key in this.monthList) {
        this.months.push(key);
      }
      let date = new Date();
      // 设置当前月份
      this.currentMonth = date.getMonth() + 1;
      // 获取今天的日期
      this.currentDay = date.getDate();
      // 设置默认显示一月份的天气
      this.chartOptions.series[0].data = this.weatherData[0][this.months[0]];
      this.chart.setOption(this.chartOptions);
    },
    mounted: function () {
      // 初始化 echarts
      this.$nextTick(() => {
        this.initChart();
      });
    },
    methods: {
      initChart() {
        // 初始化图表
        this.chart = echarts.init(document.getElementById("chart"));
        // 配置项
        this.chartOptions = {
          grid: {
            top: 35,
            bottom: 5,
            left: 10,
            right: 10,
            containLabel: true,
          },
          tooltip: {
            trigger: "axis",
            axisPointer: {
              lineStyle: {
                color: {
                  type: "linear",
                  x: 0,
                  y: 0,
                  x2: 0,
                  y2: 1,
                  colorStops: [
                    {
                      offset: 0,
                      color: "rgba(255,255,255,0)", // 0% 处的颜色
                    },
                    {
                      offset: 0.5,
                      color: "rgba(255,255,255,1)", // 100% 处的颜色
                    },
                    {
                      offset: 1,
                      color: "rgba(255,255,255,0)", // 100% 处的颜色
                    },
                  ],
                  global: false, // 缺省为 false
                },
              },
            },
          },
          xAxis: [
            {
              type: "category",
              boundaryGap: false,
              axisLabel: {
                formatter: "{value}",
                fontSize: 12,
                margin: 20,
                textStyle: {
                  color: "#bfbfbf",
                },
              },
              axisLine: {
                lineStyle: {
                  color: "#e9e9e9",
                },
              },
              splitLine: {
                show: true,
                lineStyle: {
                  color: "#f7f7f7",
                },
              },
              axisTick: {
                show: false,
              },
              // x 轴显示的数据，即天数
              data: [
                1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
                20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
              ],
            },
          ],
          yAxis: [
            {
              boundaryGap: false,
              type: "value",
              axisLabel: {
                textStyle: {
                  color: "#bfbfbf",
                },
                formatter: `{value}\u2103`,
              },
              nameTextStyle: {
                color: "# fff ",
                fontSize: 12,
                lineHeight: 40,
              },
              splitLine: {
                lineStyle: {
                  color: "#f7f7f7",
                },
              },
              axisLine: {
                show: true,
                lineStyle: {
                  color: "#e9e9e9",
                },
              },
              axisTick: {
                show: false,
              },
            },
          ],
          series: [
            {
              name: "天气",
              type: "line",
              smooth: false,
              showSymbol: false,
              symbolSize: 0,
              zlevel: 3,
              itemStyle: {
                color: "#ff6600",
                borderColor: "#a3c8d8",
              },
              lineStyle: {
                normal: {
                  width: 3,
                  color: "#ff6600",
                },
              },
              areaStyle: {
                normal: {
                  color: new echarts.graphic.LinearGradient(
                    0,
                    0,
                    0,
                    1,
                    [
                      {
                        offset: 0,
                        color: "#ff6600",
                      },
                      {
                        offset: 0.8,
                        color: "#ff9900",
                      },
                    ],
                    false
                  ),
                },
              },
              //  Y 轴显示的数据，即温度数据
              data: [
                23, 19, 30, 31, 18, 20, 16, 15, 23, 27, 29, 30, 32, 23, 25, 20,
                22, 24, 34, 24, 21, 26, 23, 24, 25, 23, 25, 28, 32, 20,
              ],
            },
          ],
        };

        // 调用此方法设置 echarts 数据
        this.chart.setOption(this.chartOptions);
      },
      // 切换月份
      changeMonth: function (item) {
        this.typeTitle = "本月天气";
        this.type = 2;
        // 点击月的数据
        this.activeMonth = item + 1;
        this.xAxisdata = [];
        this.seriesData = this.weatherData[item][this.months[item]];

        for (let index = 0; index < this.seriesData.length; index++) {
          this.xAxisdata.push(index + 1);
        }
        this.chartOptions.xAxis[0].data = this.xAxisdata;
        this.chartOptions.series[0].data = this.seriesData;
        this.chart.setOption(this.chartOptions);
      },
      // 切换未来七天天气和本月天气
      changeType: function (item) {
        this.type = item;
        console.log(this.type);
        // 本月天气数据
        let currentMonthData =
          this.weatherData[this.currentMonth - 1][
            this.months[this.currentMonth - 1]
          ];
        if (item == 1) {
          this.typeTitle = "未来7天天气";
          let seven1 = currentMonthData.slice(
            this.currentDay - 1,
            this.currentDay + 6
          );
          let seven2 = [];
          this.xAxisdata = [];
          if (seven1.length < 7) {
            let nextMonth = this.month + 1;
            let nextMonthData =
              this.weatherData[nextMonth - 1][this.months[nextMonth - 1]];
            seven2 = nextMonthData.slice(0, 7 - seven1.length);
            // 本月如果剩余小于七天，先放本月天数
            for (let index = 0; index < seven1.length; index++) {
              this.xAxisdata.push(
                `${this.currentMonth}/${this.currentDay + index}`
              );
            }
            // 本月剩余如果大于七天，剩余的放下个月天数
            for (let index = 0; index < 7 - seven1.length; index++) {
              this.xAxisdata.push(`${this.currentMonth + 1}/${index}`);
            }
          } else {
            for (let index = 0; index < 7; index++) {
              this.xAxisdata.push(
                `${this.currentMonth}/${this.currentDay + index}`
              );
            }
          }
          this.nextSevenDays = [...seven1, ...seven2];
          this.chartOptions.xAxis[0].data = this.xAxisdata;
          this.chartOptions.series[0].data = this.nextSevenDays;
          this.chart.setOption(this.chartOptions);
        } else {
          this.typeTitle = "本月天气";
          this.xAxisdata = [];
          for (let index = 0; index < currentMonthData.length; index++) {
            this.xAxisdata.push(index + 1);
          }
          this.chartOptions.xAxis[0].data = this.xAxisdata;
          this.chartOptions.series[0].data = currentMonthData;

          this.chart.setOption(this.chartOptions);
        }
      },
    },
  });
</script>
```

### 3. 十四届省赛新冠数据统计页面

### 4. 十四届国赛 github contribution

### 总结： Echarts 题目一般在中等左右，有时候会和 vue 结合到一起，考题数量 1，高频考点数据处理，x 轴数据设置、y 轴数据设置

## 备赛建议：Echarts 涉及到的 API 官方都会提供，主要以数据处理为主，难道通常在中等左右，建议优先拿分。


## vue3 题目

> 难度 : ⭐️⭐️ 到 ⭐️⭐️⭐️⭐️  

1. [表单验证器](https://www.lanqiao.cn/problems/6191/learning/)

```js
//  TODO：目标 1 当输入框的值变化时，触发 input 事件更新父组件的 v-model 值
watch(inputValue, (newValue) => {
  emit("update:modelValue", newValue);
});

//  TODO：end

// 目标 2
const is_email = (val) => {
  // TODO：待补充代码
  return /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}$/.test(val);
};

// 目标 3
// TODO：编写通用的表单验证规则 15 分
for (const field in props.rules) {
  const fieldRules = props.rules[field];
  const value = props.formData[field];

  for (const rule of fieldRules) {
    if (typeof rule === "object" && rule.validator) {
      // 处理包含 validator 函数的验证规则
      rule.validator(rule, value, (error) => {
        if (error) {
          // 如果存在错误，将错误信息添加到 errors 对象中
          errors.value[field] = error.message;
        }
      });
    } else if (rule.required && !value) {
      // 处理预定义验证规则：必填项
      errors.value[field] = rule.message;
    } else if (rule.type) {
      // 根据类型进行验证
      const validationError = validateByType(rule.type, value);
      if (!validationError) {
        if (!errors.value[field]) {
          errors.value[field] = rule.message;
        }
      }
    }
    // 验证字段长度是否在指定范围内
    if (value.length < rule.min || value.length > rule.max) {
      if (!errors.value[field]) {
        errors.value[field] = rule.message;
      }
    }
  }
}
// TODO：END
```

[API 地址](https://cn.vuejs.org/guide/components/v-model.html#v-model-arguments)

2. [不翼而飞的余额](https://www.lanqiao.cn/problems/6187/learning/)

- 考点 `vue-router`、`pinia`

```js

// 目标 1
const router = createRouter({
  history: createWebHistory(),
  routes: [
    { path: "/", component: WalletPage },
    { path: "/deposit", component: DepositPage },
  ],
});
```

```js
// store.js
// 存款事件
const depositMoney = (money) => {
  balance.value = Number(balance.value) + Number(money.value);
};
return {
  // ...
  depositMoney,
};

// DepositPage.js
<span id="deposit-balance">{{ store.balance }}</span>

function deposit() {
      store.depositMoney(depositAmount)
       depositAmount.value = '';
    }

return {
  // ...
  store,
  depositAmount
};
```

### 高频考点讲解：

1. 模板语法
2. 基础示例
3. Class 与 Style 绑定
4. 条件渲染
5. 列表渲染
6. Props
7. 组件事件


### 总结：vue3 题目属于最新改变考点，新出现的考点难道不会特别难，对于已经学了 vue3 的同学应该是个好的消息。

### 备考建议：对于 vue3 中的题目，要根据自己的实际情况和昨天时间，尽可能多得分。


## node 题目

1. 十四届省赛 Markdown 文档解析	 


2. [找到未引用的图片](https://www.lanqiao.cn/courses/18421/learning/?id=867689)

```js
const findUnlinkImages = async function () {
  const unlinkImages = []; // 未被任何 md 文件引用的图片的数组
  // TODO 请通过 Node.js 在此处继续完成代码编写
  const articles = await traversalDir(articlesPath);
  for (let i = 0; i < articles.length; i++) {
    const filename = articles[i];
    const filedir = path.join(articlesPath, filename);
    const stats = await fs.statSync(filedir); // 判断目标是否为文件
    if (stats.isFile()) {
      const md = fs.readFileSync(filedir, "utf8");
      searchImage(md); // 检索出文章内的图片链接
    }
  }
  useImgs = [...new Set(useImgs)]; // 去重，非必要
  const allNames = await traversalDir(imagesPath);
  const allImgs = await getAllImages(allNames); // 获取全部图片
  let diff = allImgs
    .concat(useImgs)
    .filter((x) => !allImgs.includes(x) || !useImgs.includes(x)); // 取差集，最好是用 ES7 的 includes；ES6 可以用 Array.from结合Set；ES5 可以用 indexOf
  for (let i = 0; i < diff.length; i++) {
    // fs.unlinkSync(path.join(imagesPath, diff[i])) // 删除文件
    unlinkImages.push(diff[i]);
  }
  // console.log(`找到了 ${diff.length} 张无效图片`);
  // 获取全部图片的相对地址
  async function getAllImages(res) {
    return res.map((x) => "../images/" + x);
  }
  // TODO-END
  return unlinkImages; // 此处应返回一个数组，如不明白，请仔细阅读题目
};
```

### node 题目属于专属大学组的考点，考点难度为中等，分数占比15 -20 分。考题数量 1，高频高点集中在 `http` 与 `fs` 模块。

### 备考建议：node 属于大学组的专属考点，通常属于逻辑题，考点设置不会特别难，简易有条件的同学积极复习 fs 和 http 模块中的常见知识点，建议拿到此题的满分或者部分分数。

### 高频考点讲解： 

- fs 
- http 模块


## axios、ajax、fetch 考点

难度：⭐️ 到 ⭐️⭐️

总结：`axios` 考点不会单独出现，而是在某道题目中，axios 的考点相对简单，属于必须拿下的分数。



当你在使用 Axios 发送请求时，你可以设置请求拦截器（Request Interceptors）和响应拦截器（Response Interceptors），这些拦截器可以让你在请求发送前和响应返回前进行一些额外的操作。下面我会详细讲解这两种拦截器，并提供一些相关的示例。

### 请求拦截器（Request Interceptors）

请求拦截器允许你在发送请求之前对其进行修改或添加一些自定义逻辑。常见的用例包括添加认证信息、在每个请求上添加特定的头部、转换请求数据等。

当涉及 Axios 的详细讲解时，我们将覆盖以下几个方面：

1. 发送 GET 请求和 POST 请求的例子。
2. 请求拦截器和响应拦截器的使用。
3. 设置请求头和响应头。

首先，我们将安装 Axios，并使用一个示例 API 来演示这些功能。

然后，我们可以编写一些 Axios 的代码：

```javascript
const axios = require('axios');

// 设置基础 URL
axios.defaults.baseURL = 'https://jsonplaceholder.typicode.com';

// 请求拦截器
axios.interceptors.request.use(config => {
  console.log('Request Interceptor');
  // 在发送请求之前做些什么
  return config;
}, error => {
  // 对请求错误做些什么
  return Promise.reject(error);
});

// 响应拦截器
axios.interceptors.response.use(response => {
  console.log('Response Interceptor');
  // 对响应数据做些什么
  return response;
}, error => {
  // 对响应错误做些什么
  return Promise.reject(error);
});

// 发送 GET 请求
axios.get('/posts')
  .then(response => {
    console.log('GET Request Response:', response.data);
  })
  .catch(error => {
    console.error('GET Request Error:', error);
  });

// 发送 POST 请求
axios.post('/posts', {
    title: 'foo',
    body: 'bar',
    userId: 1
  })
  .then(response => {
    console.log('POST Request Response:', response.data);
  })
  .catch(error => {
    console.error('POST Request Error:', error);
  });
```

在这个例子中：

- 我们首先导入了 Axios 模块。
- 设置了 Axios 的默认基础 URL。
- 我们定义了请求拦截器和响应拦截器，以便在请求发送前和响应返回前进行一些操作。
- 发送了一个 GET 请求和一个 POST 请求。
- 对于 GET 请求，我们打印了返回的数据。
- 对于 POST 请求，我们打印了返回的数据。
- 在控制台中，你会看到请求拦截器和响应拦截器的输出。

在上述例子中，我们还没有设置请求头或响应头。现在，我们将添加这部分内容。

```javascript
// 发送 GET 请求，并设置请求头
axios.get('/posts', {
    headers: {
      'Authorization': 'Bearer token',
      'Content-Type': 'application/json'
    }
  })
  .then(response => {
    console.log('GET Request Response:', response.data);
  })
  .catch(error => {
    console.error('GET Request Error:', error);
  });

// 发送 POST 请求，并设置请求头
axios.post('/posts', {
    title: 'foo',
    body: 'bar',
    userId: 1
  }, {
    headers: {
      'Authorization': 'Bearer token',
      'Content-Type': 'application/json'
    }
  })
  .then(response => {
    console.log('POST Request Response:', response.data);
  })
  .catch(error => {
    console.error('POST Request Error:', error);
  });
```

在这个例子中，我们为每个请求设置了请求头，其中包括授权令牌（Authorization）和 Content-Type。你可以根据自己的需要添加或修改请求头。

综上所述，我们通过这个示例详细讲解了 Axios 的使用方法，包括发送 GET 请求和 POST 请求、设置请求拦截器和响应拦截器、以及设置请求头和响应头。这些功能使得 Axios 成为一个非常强大且灵活的 HTTP 客户端库。


#### 设置请求拦截器

你可以通过 `axios.interceptors.request.use()` 方法来设置请求拦截器。这个方法接受两个函数作为参数：一个用于处理请求成功时的回调函数，另一个用于处理请求失败时的回调函数。

```javascript
// 设置请求拦截器
axios.interceptors.request.use(
  function(config) {
    // 在请求发送之前做一些操作
    console.log('Request Interceptor - Request Sent:', config);
    
    // 示例：添加请求头
    config.headers.Authorization = 'Bearer your_token_here';

    return config;
  },
  function(error) {
    // 对请求错误做些什么
    console.error('Request Interceptor - Request Error:', error);
    return Promise.reject(error);
  }
);
```

### 响应拦截器（Response Interceptors）

响应拦截器允许你在接收到响应数据之前对其进行修改或添加一些自定义逻辑。常见的用例包括全局错误处理、对响应数据进行预处理等。

#### 设置响应拦截器

你可以通过 `axios.interceptors.response.use()` 方法来设置响应拦截器。这个方法接受两个函数作为参数：一个用于处理成功响应的回调函数，另一个用于处理失败响应的回调函数。

```javascript
// 设置响应拦截器
axios.interceptors.response.use(
  function(response) {
    // 对响应数据做些事
    console.log('Response Interceptor - Response Received:', response);
    
    // 示例：对响应数据进行处理
    response.data = response.data.results; // 假设响应数据在 results 字段中
    
    return response;
  },
  function(error) {
    // 对响应错误做些什么
    console.error('Response Interceptor - Response Error:', error);
    return Promise.reject(error);
  }
);
```

### 示例：GET 和 POST 请求

下面是一个包含 GET 和 POST 请求的示例，同时演示了请求拦截器和响应拦截器的使用。

```javascript
// 设置请求拦截器
axios.interceptors.request.use(config => {
  // 在请求发送之前做一些操作
  console.log('Request Interceptor - Request Sent:', config);
  
  // 示例：添加请求头
  config.headers.Authorization = 'Bearer your_token_here';

  return config;
}, error => {
  // 对请求错误做些什么
  console.error('Request Interceptor - Request Error:', error);
  return Promise.reject(error);
});

// 设置响应拦截器
axios.interceptors.response.use(response => {
  // 对响应数据做些事
  console.log('Response Interceptor - Response Received:', response);
  
  // 示例：对响应数据进行处理
  response.data = response.data.results; // 假设响应数据在 results 字段中
  
  return response;
}, error => {
  // 对响应错误做些什么
  console.error('Response Interceptor - Response Error:', error);
  return Promise.reject(error);
});

// 发送 GET 请求
axios.get('https://api.example.com/data')
  .then(response => {
    console.log('GET Request Response:', response.data);
  })
  .catch(error => {
    console.error('GET Request Error:', error);
  });

// 发送 POST 请求
axios.post('https://api.example.com/post', {key: 'value' })
  .then(response => {
    console.log('POST Request Response:', response.data);
  })
  .catch(error => {
    console.error('POST Request Error:', error);
  });
```

这个示例展示了如何设置请求拦截器和响应拦截器，并进行了 GET 和 POST 请求。在实际应用中，你可以根据自己的需求定制拦截器的行为，以满足特定的业务逻辑和需求。

2. fetch 请求（和原生 `ajax` 请求掌握其中一种写法即可，学习的时候建议都学习）
  
```html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Simple Fetch Example</title>
</head>
<body>

<h2>Simple Fetch Example</h2>
<div id="response"></div>

<script>
// 发起Fetch请求
fetch('https://jsonplaceholder.typicode.com/posts/1')
  .then(response => {
    // 检查响应状态
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    // 将响应解析为JSON格式
    return response.json();
  })
  .then(data => {
    // 将响应数据显示在页面上
    document.getElementById('response').textContent = JSON.stringify(data);
  })
  .catch(error => {
    // 处理请求错误
    document.getElementById('response').textContent = 'Error: ' + error.message;
  });
</script>

</body>
</html>
```

1. 原生 ajax 请求

```html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AJAX Example</title>
</head>
<body>

<button id="loadDataBtn">Load Data</button>
<div id="output"></div>

<script>
document.getElementById("loadDataBtn").addEventListener("click", function() {
  var xhr = new XMLHttpRequest();
  
  xhr.onload = function() {
    if (xhr.status >= 200 && xhr.status < 300) {
      document.getElementById("output").innerHTML = xhr.responseText;
    } else {
      document.getElementById("output").innerHTML = "Error: " + xhr.status;
    }
  };
  
  xhr.onerror = function() {
    document.getElementById("output").innerHTML = "Request failed";
  };
  
  xhr.open("GET", "example-data.txt"); // Replace "example-data.txt" with your actual URL
  xhr.send();
});
</script>

</body>
</html>
```